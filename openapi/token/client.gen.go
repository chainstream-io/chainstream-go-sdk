// Package token provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package token

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for ChainSymbol.
const (
	Bsc ChainSymbol = "bsc"
	Eth ChainSymbol = "eth"
	Sol ChainSymbol = "sol"
)

// Defines values for DexPoolDTOLiquidityModel.
const (
	DexPoolDTOLiquidityModelN0 DexPoolDTOLiquidityModel = 0
	DexPoolDTOLiquidityModelN1 DexPoolDTOLiquidityModel = 1
	DexPoolDTOLiquidityModelN2 DexPoolDTOLiquidityModel = 2
	DexPoolDTOLiquidityModelN3 DexPoolDTOLiquidityModel = 3
	DexPoolDTOLiquidityModelN4 DexPoolDTOLiquidityModel = 4
)

// Defines values for DexPoolDTOType.
const (
	DexPoolDTOTypeN0 DexPoolDTOType = 0
	DexPoolDTOTypeN1 DexPoolDTOType = 1
	DexPoolDTOTypeN2 DexPoolDTOType = 2
	DexPoolDTOTypeN3 DexPoolDTOType = 3
	DexPoolDTOTypeN4 DexPoolDTOType = 4
)

// Defines values for DexPoolDTOVersion.
const (
	N0 DexPoolDTOVersion = 0
	N1 DexPoolDTOVersion = 1
	N2 DexPoolDTOVersion = 2
	N3 DexPoolDTOVersion = 3
)

// Defines values for FilterConditionField.
const (
	FilterConditionFieldMarketDataCreatorHoldings      FilterConditionField = "marketData.creatorHoldings"
	FilterConditionFieldMarketDataCreatorHoldingsRatio FilterConditionField = "marketData.creatorHoldingsRatio"
	FilterConditionFieldMarketDataHolders              FilterConditionField = "marketData.holders"
	FilterConditionFieldMarketDataMarketCapInUsd       FilterConditionField = "marketData.marketCapInUsd"
	FilterConditionFieldMarketDataMaxPoolTvlInUsd      FilterConditionField = "marketData.maxPoolTvlInUsd"
	FilterConditionFieldMarketDataPriceInUsd           FilterConditionField = "marketData.priceInUsd"
	FilterConditionFieldMarketDataTop100HoldingsRatio  FilterConditionField = "marketData.top100HoldingsRatio"
	FilterConditionFieldMarketDataTop100TotalHoldings  FilterConditionField = "marketData.top100TotalHoldings"
	FilterConditionFieldMarketDataTop10HoldingsRatio   FilterConditionField = "marketData.top10HoldingsRatio"
	FilterConditionFieldMarketDataTop10TotalHoldings   FilterConditionField = "marketData.top10TotalHoldings"
	FilterConditionFieldMarketDataTotalTvlInUsd        FilterConditionField = "marketData.totalTvlInUsd"
	FilterConditionFieldStatsBuys15m                   FilterConditionField = "stats.buys15m"
	FilterConditionFieldStatsBuys1h                    FilterConditionField = "stats.buys1h"
	FilterConditionFieldStatsBuys1m                    FilterConditionField = "stats.buys1m"
	FilterConditionFieldStatsBuys24h                   FilterConditionField = "stats.buys24h"
	FilterConditionFieldStatsBuys30m                   FilterConditionField = "stats.buys30m"
	FilterConditionFieldStatsBuys4h                    FilterConditionField = "stats.buys4h"
	FilterConditionFieldStatsBuys5m                    FilterConditionField = "stats.buys5m"
	FilterConditionFieldStatsPriceChangeRatioInUsd1h   FilterConditionField = "stats.priceChangeRatioInUsd1h"
	FilterConditionFieldStatsPriceChangeRatioInUsd1m   FilterConditionField = "stats.priceChangeRatioInUsd1m"
	FilterConditionFieldStatsPriceChangeRatioInUsd24h  FilterConditionField = "stats.priceChangeRatioInUsd24h"
	FilterConditionFieldStatsPriceChangeRatioInUsd4h   FilterConditionField = "stats.priceChangeRatioInUsd4h"
	FilterConditionFieldStatsPriceChangeRatioInUsd5m   FilterConditionField = "stats.priceChangeRatioInUsd5m"
	FilterConditionFieldStatsSells15m                  FilterConditionField = "stats.sells15m"
	FilterConditionFieldStatsSells1h                   FilterConditionField = "stats.sells1h"
	FilterConditionFieldStatsSells1m                   FilterConditionField = "stats.sells1m"
	FilterConditionFieldStatsSells24h                  FilterConditionField = "stats.sells24h"
	FilterConditionFieldStatsSells30m                  FilterConditionField = "stats.sells30m"
	FilterConditionFieldStatsSells4h                   FilterConditionField = "stats.sells4h"
	FilterConditionFieldStatsSells5m                   FilterConditionField = "stats.sells5m"
	FilterConditionFieldStatsTraders1h                 FilterConditionField = "stats.traders1h"
	FilterConditionFieldStatsTraders1m                 FilterConditionField = "stats.traders1m"
	FilterConditionFieldStatsTraders24h                FilterConditionField = "stats.traders24h"
	FilterConditionFieldStatsTraders4h                 FilterConditionField = "stats.traders4h"
	FilterConditionFieldStatsTraders5m                 FilterConditionField = "stats.traders5m"
	FilterConditionFieldStatsTrades1h                  FilterConditionField = "stats.trades1h"
	FilterConditionFieldStatsTrades1m                  FilterConditionField = "stats.trades1m"
	FilterConditionFieldStatsTrades24h                 FilterConditionField = "stats.trades24h"
	FilterConditionFieldStatsTrades4h                  FilterConditionField = "stats.trades4h"
	FilterConditionFieldStatsTrades5m                  FilterConditionField = "stats.trades5m"
	FilterConditionFieldStatsVolumesInUsd1h            FilterConditionField = "stats.volumesInUsd1h"
	FilterConditionFieldStatsVolumesInUsd1m            FilterConditionField = "stats.volumesInUsd1m"
	FilterConditionFieldStatsVolumesInUsd24h           FilterConditionField = "stats.volumesInUsd24h"
	FilterConditionFieldStatsVolumesInUsd4h            FilterConditionField = "stats.volumesInUsd4h"
	FilterConditionFieldStatsVolumesInUsd5m            FilterConditionField = "stats.volumesInUsd5m"
	FilterConditionFieldTokenCreatedAt                 FilterConditionField = "tokenCreatedAt"
)

// Defines values for Resolution.
const (
	N12h Resolution = "12h"
	N15m Resolution = "15m"
	N15s Resolution = "15s"
	N1d  Resolution = "1d"
	N1h  Resolution = "1h"
	N1m  Resolution = "1m"
	N1s  Resolution = "1s"
	N30s Resolution = "30s"
	N4h  Resolution = "4h"
	N5m  Resolution = "5m"
)

// Defines values for TokenCreationDTOType.
const (
	TokenCreationDTOTypeBurn   TokenCreationDTOType = "burn"
	TokenCreationDTOTypeCreate TokenCreationDTOType = "create"
	TokenCreationDTOTypeMint   TokenCreationDTOType = "mint"
)

// Defines values for TokenTraderTag.
const (
	Bluechip TokenTraderTag = "bluechip"
	Bundle   TokenTraderTag = "bundle"
	Dev      TokenTraderTag = "dev"
	Fresh    TokenTraderTag = "fresh"
	Insider  TokenTraderTag = "insider"
	Kol      TokenTraderTag = "kol"
	Pro      TokenTraderTag = "pro"
	Sandwish TokenTraderTag = "sandwish"
	Sniper   TokenTraderTag = "sniper"
)

// Defines values for SearchParamsSort.
const (
	SearchParamsSortAsc  SearchParamsSort = "asc"
	SearchParamsSortDesc SearchParamsSort = "desc"
)

// Defines values for SearchParamsSortBy.
const (
	SearchParamsSortByH24Transactions SearchParamsSortBy = "h24Transactions"
	SearchParamsSortByH24VolumeInUsd  SearchParamsSortBy = "h24VolumeInUsd"
	SearchParamsSortByHolderCount     SearchParamsSortBy = "holderCount"
	SearchParamsSortByLiquidityInUsd  SearchParamsSortBy = "liquidityInUsd"
	SearchParamsSortByMarketCapInUsd  SearchParamsSortBy = "marketCapInUsd"
	SearchParamsSortByPriceInUsd      SearchParamsSortBy = "priceInUsd"
	SearchParamsSortByTokenCreatedAt  SearchParamsSortBy = "tokenCreatedAt"
)

// Defines values for ListTokenParamsDirection.
const (
	ListTokenParamsDirectionNext ListTokenParamsDirection = "next"
	ListTokenParamsDirectionPrev ListTokenParamsDirection = "prev"
)

// Defines values for ListTokenParamsSort.
const (
	ListTokenParamsSortAsc  ListTokenParamsSort = "asc"
	ListTokenParamsSortDesc ListTokenParamsSort = "desc"
)

// Defines values for ListTokenParamsSortBy.
const (
	H1BuyVolumeInUsd    ListTokenParamsSortBy = "h1BuyVolumeInUsd"
	H1Buyers            ListTokenParamsSortBy = "h1Buyers"
	H1Buys              ListTokenParamsSortBy = "h1Buys"
	H1PriceChangeRatio  ListTokenParamsSortBy = "h1PriceChangeRatio"
	H1SellVolumeInUsd   ListTokenParamsSortBy = "h1SellVolumeInUsd"
	H1Sellers           ListTokenParamsSortBy = "h1Sellers"
	H1Sells             ListTokenParamsSortBy = "h1Sells"
	H1Trades            ListTokenParamsSortBy = "h1Trades"
	H1VolumeInUsd       ListTokenParamsSortBy = "h1VolumeInUsd"
	H24BuyVolumeInUsd   ListTokenParamsSortBy = "h24BuyVolumeInUsd"
	H24Buyers           ListTokenParamsSortBy = "h24Buyers"
	H24Buys             ListTokenParamsSortBy = "h24Buys"
	H24PriceChangeRatio ListTokenParamsSortBy = "h24PriceChangeRatio"
	H24SellVolumeInUsd  ListTokenParamsSortBy = "h24SellVolumeInUsd"
	H24Sellers          ListTokenParamsSortBy = "h24Sellers"
	H24Sells            ListTokenParamsSortBy = "h24Sells"
	H24Trades           ListTokenParamsSortBy = "h24Trades"
	H24VolumeInUsd      ListTokenParamsSortBy = "h24VolumeInUsd"
	H4BuyVolumeInUsd    ListTokenParamsSortBy = "h4BuyVolumeInUsd"
	H4Buyers            ListTokenParamsSortBy = "h4Buyers"
	H4Buys              ListTokenParamsSortBy = "h4Buys"
	H4PriceChangeRatio  ListTokenParamsSortBy = "h4PriceChangeRatio"
	H4SellVolumeInUsd   ListTokenParamsSortBy = "h4SellVolumeInUsd"
	H4Sellers           ListTokenParamsSortBy = "h4Sellers"
	H4Sells             ListTokenParamsSortBy = "h4Sells"
	H4Trades            ListTokenParamsSortBy = "h4Trades"
	H4VolumeInUsd       ListTokenParamsSortBy = "h4VolumeInUsd"
	M15BuyVolumeInUsd   ListTokenParamsSortBy = "m15BuyVolumeInUsd"
	M15Buyers           ListTokenParamsSortBy = "m15Buyers"
	M15Buys             ListTokenParamsSortBy = "m15Buys"
	M15PriceChangeRatio ListTokenParamsSortBy = "m15PriceChangeRatio"
	M15SellVolumeInUsd  ListTokenParamsSortBy = "m15SellVolumeInUsd"
	M15Sellers          ListTokenParamsSortBy = "m15Sellers"
	M15Sells            ListTokenParamsSortBy = "m15Sells"
	M15Trades           ListTokenParamsSortBy = "m15Trades"
	M15VolumeInUsd      ListTokenParamsSortBy = "m15VolumeInUsd"
	M1BuyVolumeInUsd    ListTokenParamsSortBy = "m1BuyVolumeInUsd"
	M1Buyers            ListTokenParamsSortBy = "m1Buyers"
	M1Buys              ListTokenParamsSortBy = "m1Buys"
	M1PriceChangeRatio  ListTokenParamsSortBy = "m1PriceChangeRatio"
	M1SellVolumeInUsd   ListTokenParamsSortBy = "m1SellVolumeInUsd"
	M1Sellers           ListTokenParamsSortBy = "m1Sellers"
	M1Sells             ListTokenParamsSortBy = "m1Sells"
	M1Trades            ListTokenParamsSortBy = "m1Trades"
	M1VolumeInUsd       ListTokenParamsSortBy = "m1VolumeInUsd"
	M30BuyVolumeInUsd   ListTokenParamsSortBy = "m30BuyVolumeInUsd"
	M30Buyers           ListTokenParamsSortBy = "m30Buyers"
	M30Buys             ListTokenParamsSortBy = "m30Buys"
	M30PriceChangeRatio ListTokenParamsSortBy = "m30PriceChangeRatio"
	M30SellVolumeInUsd  ListTokenParamsSortBy = "m30SellVolumeInUsd"
	M30Sellers          ListTokenParamsSortBy = "m30Sellers"
	M30Sells            ListTokenParamsSortBy = "m30Sells"
	M30Trades           ListTokenParamsSortBy = "m30Trades"
	M30VolumeInUsd      ListTokenParamsSortBy = "m30VolumeInUsd"
	M5BuyVolumeInUsd    ListTokenParamsSortBy = "m5BuyVolumeInUsd"
	M5Buyers            ListTokenParamsSortBy = "m5Buyers"
	M5Buys              ListTokenParamsSortBy = "m5Buys"
	M5PriceChangeRatio  ListTokenParamsSortBy = "m5PriceChangeRatio"
	M5SellVolumeInUsd   ListTokenParamsSortBy = "m5SellVolumeInUsd"
	M5Sellers           ListTokenParamsSortBy = "m5Sellers"
	M5Sells             ListTokenParamsSortBy = "m5Sells"
	M5Trades            ListTokenParamsSortBy = "m5Trades"
	M5VolumeInUsd       ListTokenParamsSortBy = "m5VolumeInUsd"
)

// Defines values for GetTokensParamsSortBy.
const (
	MarketDataCreatorHoldings      GetTokensParamsSortBy = "marketData.creatorHoldings"
	MarketDataCreatorHoldingsRatio GetTokensParamsSortBy = "marketData.creatorHoldingsRatio"
	MarketDataHolders              GetTokensParamsSortBy = "marketData.holders"
	MarketDataMarketCapInUsd       GetTokensParamsSortBy = "marketData.marketCapInUsd"
	MarketDataMaxPoolTvlInUsd      GetTokensParamsSortBy = "marketData.maxPoolTvlInUsd"
	MarketDataPriceInUsd           GetTokensParamsSortBy = "marketData.priceInUsd"
	MarketDataTop100HoldingsRatio  GetTokensParamsSortBy = "marketData.top100HoldingsRatio"
	MarketDataTop100TotalHoldings  GetTokensParamsSortBy = "marketData.top100TotalHoldings"
	MarketDataTop10HoldingsRatio   GetTokensParamsSortBy = "marketData.top10HoldingsRatio"
	MarketDataTop10TotalHoldings   GetTokensParamsSortBy = "marketData.top10TotalHoldings"
	MarketDataTotalTvlInUsd        GetTokensParamsSortBy = "marketData.totalTvlInUsd"
	StatsBuys15m                   GetTokensParamsSortBy = "stats.buys15m"
	StatsBuys1h                    GetTokensParamsSortBy = "stats.buys1h"
	StatsBuys1m                    GetTokensParamsSortBy = "stats.buys1m"
	StatsBuys24h                   GetTokensParamsSortBy = "stats.buys24h"
	StatsBuys30m                   GetTokensParamsSortBy = "stats.buys30m"
	StatsBuys4h                    GetTokensParamsSortBy = "stats.buys4h"
	StatsBuys5m                    GetTokensParamsSortBy = "stats.buys5m"
	StatsPriceChangeRatioInUsd1h   GetTokensParamsSortBy = "stats.priceChangeRatioInUsd1h"
	StatsPriceChangeRatioInUsd1m   GetTokensParamsSortBy = "stats.priceChangeRatioInUsd1m"
	StatsPriceChangeRatioInUsd24h  GetTokensParamsSortBy = "stats.priceChangeRatioInUsd24h"
	StatsPriceChangeRatioInUsd4h   GetTokensParamsSortBy = "stats.priceChangeRatioInUsd4h"
	StatsPriceChangeRatioInUsd5m   GetTokensParamsSortBy = "stats.priceChangeRatioInUsd5m"
	StatsSells15m                  GetTokensParamsSortBy = "stats.sells15m"
	StatsSells1h                   GetTokensParamsSortBy = "stats.sells1h"
	StatsSells1m                   GetTokensParamsSortBy = "stats.sells1m"
	StatsSells24h                  GetTokensParamsSortBy = "stats.sells24h"
	StatsSells30m                  GetTokensParamsSortBy = "stats.sells30m"
	StatsSells4h                   GetTokensParamsSortBy = "stats.sells4h"
	StatsSells5m                   GetTokensParamsSortBy = "stats.sells5m"
	StatsTraders1h                 GetTokensParamsSortBy = "stats.traders1h"
	StatsTraders1m                 GetTokensParamsSortBy = "stats.traders1m"
	StatsTraders24h                GetTokensParamsSortBy = "stats.traders24h"
	StatsTraders4h                 GetTokensParamsSortBy = "stats.traders4h"
	StatsTraders5m                 GetTokensParamsSortBy = "stats.traders5m"
	StatsTrades1h                  GetTokensParamsSortBy = "stats.trades1h"
	StatsTrades1m                  GetTokensParamsSortBy = "stats.trades1m"
	StatsTrades24h                 GetTokensParamsSortBy = "stats.trades24h"
	StatsTrades4h                  GetTokensParamsSortBy = "stats.trades4h"
	StatsTrades5m                  GetTokensParamsSortBy = "stats.trades5m"
	StatsVolumesInUsd1h            GetTokensParamsSortBy = "stats.volumesInUsd1h"
	StatsVolumesInUsd1m            GetTokensParamsSortBy = "stats.volumesInUsd1m"
	StatsVolumesInUsd24h           GetTokensParamsSortBy = "stats.volumesInUsd24h"
	StatsVolumesInUsd4h            GetTokensParamsSortBy = "stats.volumesInUsd4h"
	StatsVolumesInUsd5m            GetTokensParamsSortBy = "stats.volumesInUsd5m"
	TokenCreatedAt                 GetTokensParamsSortBy = "tokenCreatedAt"
)

// Defines values for GetTokensParamsSortDirection.
const (
	ASC  GetTokensParamsSortDirection = "ASC"
	DESC GetTokensParamsSortDirection = "DESC"
)

// Defines values for GetHoldersParamsDirection.
const (
	GetHoldersParamsDirectionNext GetHoldersParamsDirection = "next"
	GetHoldersParamsDirectionPrev GetHoldersParamsDirection = "prev"
)

// Defines values for GetMintAndBurnParamsDirection.
const (
	GetMintAndBurnParamsDirectionNext GetMintAndBurnParamsDirection = "next"
	GetMintAndBurnParamsDirectionPrev GetMintAndBurnParamsDirection = "prev"
)

// Defines values for GetMintAndBurnParamsType.
const (
	GetMintAndBurnParamsTypeAll  GetMintAndBurnParamsType = "all"
	GetMintAndBurnParamsTypeBurn GetMintAndBurnParamsType = "burn"
	GetMintAndBurnParamsTypeMint GetMintAndBurnParamsType = "mint"
)

// Defines values for GetPoolsParamsDirection.
const (
	GetPoolsParamsDirectionNext GetPoolsParamsDirection = "next"
	GetPoolsParamsDirectionPrev GetPoolsParamsDirection = "prev"
)

// Defines values for GetPoolsParamsSortBy.
const (
	TvlInSol GetPoolsParamsSortBy = "tvlInSol"
	TvlInUsd GetPoolsParamsSortBy = "tvlInUsd"
)

// Defines values for GetPoolsParamsSortDirection.
const (
	Asc  GetPoolsParamsSortDirection = "asc"
	Desc GetPoolsParamsSortDirection = "desc"
)

// Defines values for GetPricesParamsDirection.
const (
	Next GetPricesParamsDirection = "next"
	Prev GetPricesParamsDirection = "prev"
)

// Candle defines model for Candle.
type Candle struct {
	// Close DTO.CANDLE.CLOSE
	Close string `json:"close"`

	// High DTO.CANDLE.HIGH
	High string `json:"high"`

	// Low DTO.CANDLE.LOW
	Low string `json:"low"`

	// Open DTO.CANDLE.OPEN
	Open string `json:"open"`

	// Resolution DTO.CANDLE.RESOLUTION
	Resolution Resolution `json:"resolution"`

	// Time DTO.CANDLE.TIME
	Time int64 `json:"time"`

	// Volume DTO.CANDLE.VOLUME
	Volume string `json:"volume"`
}

// ChainSymbol defines model for ChainSymbol.
type ChainSymbol string

// DevTokenDTO defines model for DevTokenDTO.
type DevTokenDTO struct {
	// Address DTO.DEV_TOKEN.ADDRESS
	Address string `json:"address"`

	// MarketData DTO.DEV_TOKEN.MARKET_DATA
	MarketData TokenMarketData `json:"marketData"`

	// Metadata DTO.DEV_TOKEN.METADATA
	Metadata TokenMetadata `json:"metadata"`

	// Stats DTO.DEV_TOKEN.STATS
	Stats TokenStat `json:"stats"`
}

// DexPoolDTO defines model for DexPoolDTO.
type DexPoolDTO struct {
	// Chain DTO.DEX.CHAIN
	Chain string `json:"chain"`

	// CreatedBlockTimestamp DTO.DEXPOOL.CREATED_BLOCK_TIMESTAMP
	CreatedBlockTimestamp *string `json:"createdBlockTimestamp,omitempty"`

	// FeeRate DTO.DEXPOOL.FEE_RATE
	FeeRate *string `json:"feeRate,omitempty"`

	// Image DTO.DEX.IMAGE
	Image *string `json:"image,omitempty"`

	// LiquidityModel DTO.DEXPOOL.LIQUIDITY_MODEL
	LiquidityModel *DexPoolDTOLiquidityModel `json:"liquidityModel,omitempty"`

	// PoolAddress DTO.DEXPOOL.POOL_ADDRESS
	PoolAddress string `json:"poolAddress"`

	// ProgramAddress DTO.DEX.PROGRAM_ADDRESS
	ProgramAddress *string `json:"programAddress,omitempty"`

	// ProtocolFamily DTO.DEX.PROTOCOL_FAMILY
	ProtocolFamily *string `json:"protocolFamily,omitempty"`

	// ProtocolName DTO.DEXPOOL.PROTOCOL_NAME
	ProtocolName *string `json:"protocolName,omitempty"`

	// TickSpacing DTO.DEXPOOL.TICK_SPACING
	TickSpacing *int `json:"tickSpacing,omitempty"`

	// TokenAAddress DTO.DEXPOOL.TOKEN_A
	TokenAAddress string `json:"tokenAAddress"`

	// TokenALiquidity DTO.DEXPOOL.TOKEN_A_LIQUIDITY
	TokenALiquidity *DexPoolTokenLiquidity `json:"tokenALiquidity,omitempty"`

	// TokenBAddress DTO.DEXPOOL.TOKEN_B
	TokenBAddress string `json:"tokenBAddress"`

	// TokenBLiquidity DTO.DEXPOOL.TOKEN_B_LIQUIDITY
	TokenBLiquidity *DexPoolTokenLiquidity `json:"tokenBLiquidity,omitempty"`

	// TokenCount DTO.DEXPOOL.TOKEN_COUNT
	TokenCount *int `json:"tokenCount,omitempty"`

	// TvlInSol DTO.DEXPOOL.TVL_SOL
	TvlInSol *string `json:"tvlInSol,omitempty"`

	// TvlInUsd DTO.DEXPOOL.TVL_USD
	TvlInUsd *string `json:"tvlInUsd,omitempty"`

	// Type DTO.DEXPOOL.TYPE
	Type *DexPoolDTOType `json:"type,omitempty"`

	// Version DTO.DEXPOOL.VERSION
	Version *DexPoolDTOVersion `json:"version,omitempty"`
}

// DexPoolDTOLiquidityModel DTO.DEXPOOL.LIQUIDITY_MODEL
type DexPoolDTOLiquidityModel float32

// DexPoolDTOType DTO.DEXPOOL.TYPE
type DexPoolDTOType float32

// DexPoolDTOVersion DTO.DEXPOOL.VERSION
type DexPoolDTOVersion float32

// DexPoolPage defines model for DexPoolPage.
type DexPoolPage struct {
	// Data DTO.DEXPOOL.PAGE.DATA
	Data []DexPoolDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// DexPoolTokenLiquidity defines model for DexPoolTokenLiquidity.
type DexPoolTokenLiquidity struct {
	// AmountInNative DTO.DEXPOOL.AMOUNT_IN_NATIVE
	AmountInNative string `json:"amountInNative"`

	// AmountInUsd DTO.DEXPOOL.AMOUNT_IN_USD
	AmountInUsd string `json:"amountInUsd"`

	// PriceNative DTO.DEXPOOL.PRICE_NATIVE
	PriceNative string `json:"priceNative"`

	// PriceUsd DTO.DEXPOOL.PRICE_USD
	PriceUsd string `json:"priceUsd"`

	// TokenAddress DTO.DEXPOOL.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TokenDecimals DTO.DEXPOOL.TOKEN_DECIMALS
	TokenDecimals int `json:"tokenDecimals"`

	// VaultAmount DTO.DEXPOOL.VAULT_AMOUNT
	VaultAmount string `json:"vaultAmount"`
}

// FilterCondition defines model for FilterCondition.
type FilterCondition struct {
	// Field DTO.TOKEN.FILTER.FIELD
	Field *FilterConditionField `json:"field,omitempty"`

	// Max DTO.TOKEN.FILTER.MAX
	Max *string `json:"max,omitempty"`

	// Min DTO.TOKEN.FILTER.MIN
	Min *string `json:"min,omitempty"`
}

// FilterConditionField DTO.TOKEN.FILTER.FIELD
type FilterConditionField string

// Resolution defines model for Resolution.
type Resolution string

// Token defines model for Token.
type Token struct {
	// Address DTO.TOKEN.METADATA.ADDRESS
	Address string `json:"address"`

	// Chain DTO.TOKEN.METADATA.CHAIN
	Chain string `json:"chain"`

	// Decimals DTO.TOKEN.METADATA.DECIMALS
	Decimals int64 `json:"decimals"`

	// Description DTO.TOKEN.METADATA.DESCRIPTION
	Description *string `json:"description,omitempty"`

	// DevLastTokenCreatedAt DTO.TOKEN.METADATA.DEV_LAST_TOKEN_CREATED_AT
	DevLastTokenCreatedAt *string `json:"devLastTokenCreatedAt,omitempty"`

	// DevTotalTokens DTO.TOKEN.METADATA.DEV_TOTAL_TOKENS
	DevTotalTokens *string `json:"devTotalTokens,omitempty"`

	// Extension DTO.TOKEN.EXTENSION
	Extension *map[string]interface{} `json:"extension,omitempty"`

	// Extra DTO.TOKEN.METADATA.EXTRA
	Extra *TokenExtraDTO `json:"extra,omitempty"`

	// ImageUrl DTO.TOKEN.METADATA.IMAGE_URL
	ImageUrl *string `json:"imageUrl,omitempty"`

	// Liquidity DTO.TOKEN.LIQUIDITY
	Liquidity *[]DexPoolDTO `json:"liquidity,omitempty"`

	// Market DTO.TOKEN.MARKET_ID
	Market *string `json:"market,omitempty"`

	// MarketData DTO.TOKEN.MARKET_CAP_INFO
	MarketData TokenMarketData `json:"marketData"`

	// MetadataAddress DTO.TOKEN.METADATA.METADATA_ADDRESS
	MetadataAddress *string `json:"metadataAddress,omitempty"`

	// Name DTO.TOKEN.METADATA.NAME
	Name string `json:"name"`

	// SocialMedias DTO.TOKEN.METADATA.SOCIAL_MEDIAS
	SocialMedias *TokenSocialMediasDTO `json:"socialMedias,omitempty"`

	// Stats DTO.TOKEN.STATS
	Stats *TokenStat `json:"stats,omitempty"`

	// Symbol DTO.TOKEN.METADATA.SYMBOL
	Symbol string `json:"symbol"`

	// TokenCreatedAt DTO.TOKEN.METADATA.TOKEN_CREATED_AT
	TokenCreatedAt *int64 `json:"tokenCreatedAt,omitempty"`

	// TokenCreators DTO.TOKEN.METADATA.TOKEN_CREATORS
	TokenCreators *[]TokenCreatorsDTO `json:"tokenCreators,omitempty"`

	// Uri DTO.TOKEN.METADATA.URI
	Uri *string `json:"uri,omitempty"`
}

// TokenCreationDTO defines model for TokenCreationDTO.
type TokenCreationDTO struct {
	// BlockHash DTO.TOKEN.CREATION.BLOCK_HASH
	BlockHash string `json:"blockHash"`

	// BlockHeight DTO.TOKEN.CREATION.BLOCK_HEIGHT
	BlockHeight int64 `json:"blockHeight"`

	// BlockSlot DTO.TOKEN.CREATION.BLOCK_SLOT
	BlockSlot int64 `json:"blockSlot"`

	// BlockTimestamp DTO.TOKEN.CREATION.BLOCK_TIMESTAMP
	BlockTimestamp *int64 `json:"blockTimestamp,omitempty"`

	// TokenAddress DTO.TOKEN.CREATION.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TransactionSignature DTO.TOKEN.CREATION.TRANSACTION_SIGNATURE
	TransactionSignature string `json:"transactionSignature"`

	// Type DTO.TOKEN.CREATION.TYPE
	Type TokenCreationDTOType `json:"type"`
}

// TokenCreationDTOType DTO.TOKEN.CREATION.TYPE
type TokenCreationDTOType string

// TokenCreationPage defines model for TokenCreationPage.
type TokenCreationPage struct {
	// Data DTO.TOKEN.CREATION.PAGE.DATA
	Data []TokenCreationDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TokenCreatorsDTO defines model for TokenCreatorsDTO.
type TokenCreatorsDTO struct {
	// Address DTO.TOKEN.CREATORS.ADDRESS
	Address *string `json:"address,omitempty"`

	// IsVerified DTO.TOKEN.CREATORS.IS_VERIFIED
	IsVerified *bool `json:"isVerified,omitempty"`

	// Share DTO.TOKEN.CREATORS.SHARE
	Share *int64 `json:"share,omitempty"`
}

// TokenExtraDTO defines model for TokenExtraDTO.
type TokenExtraDTO struct {
	// CollectionAddress DTO.TOKEN.EXTRA.COLLECTION_ADDRESS
	CollectionAddress *string `json:"collectionAddress,omitempty"`

	// EditionNonce DTO.TOKEN.EXTRA.EDITION_NONCE
	EditionNonce *int64 `json:"editionNonce,omitempty"`

	// FreezeAuthority DTO.TOKEN.EXTRA.FREEZE_AUTHORITY
	FreezeAuthority *string `json:"freezeAuthority,omitempty"`

	// Fungible DTO.TOKEN.EXTRA.FUNGIBLE
	Fungible *bool `json:"fungible,omitempty"`

	// IsMutable DTO.TOKEN.EXTRA.IS_MUTABLE
	IsMutable *bool `json:"isMutable,omitempty"`

	// IsNative DTO.TOKEN.EXTRA.IS_NATIVE
	IsNative *bool `json:"isNative,omitempty"`

	// IsVerifiedCollection DTO.TOKEN.EXTRA.IS_VERIFIED_COLLECTION
	IsVerifiedCollection *bool `json:"isVerifiedCollection,omitempty"`

	// IsWrapped DTO.TOKEN.EXTRA.IS_WRAPPED
	IsWrapped *bool `json:"isWrapped,omitempty"`

	// Key DTO.TOKEN.EXTRA.KEY
	Key *string `json:"key,omitempty"`

	// LaunchFromProgramAddress DTO.TOKEN.EXTRA.LAUNCH_FROM_PROGRAM_ADDRESS
	LaunchFromProgramAddress *string `json:"launchFromProgramAddress,omitempty"`

	// LaunchFromProtocolFamily DTO.TOKEN.EXTRA.LAUNCH_FROM_PROTOCOL_FAMILY
	LaunchFromProtocolFamily *string `json:"launchFromProtocolFamily,omitempty"`

	// MigratedAt DTO.TOKEN.EXTRA.MIGRATED_AT
	MigratedAt *int64 `json:"migratedAt,omitempty"`

	// MigratedToPoolAddress DTO.TOKEN.EXTRA.MIGRATED_TO_POOL_ADDRESS
	MigratedToPoolAddress *string `json:"migratedToPoolAddress,omitempty"`

	// MigratedToProgramAddress DTO.TOKEN.EXTRA.MIGRATED_TO_PROGRAM_ADDRESS
	MigratedToProgramAddress *string `json:"migratedToProgramAddress,omitempty"`

	// MigratedToProtocolFamily DTO.TOKEN.EXTRA.MIGRATED_TO_PROTOCOL_FAMILY
	MigratedToProtocolFamily *string `json:"migratedToProtocolFamily,omitempty"`

	// MintAuthority DTO.TOKEN.EXTRA.MINT_AUTHORITY
	MintAuthority *string `json:"mintAuthority,omitempty"`

	// PrimarySaleHappened DTO.TOKEN.EXTRA.PRIMARY_SALE_HAPPENED
	PrimarySaleHappened *bool `json:"primarySaleHappened,omitempty"`

	// ProgramAddress DTO.TOKEN.EXTRA.PROGRAM_ADDRESS
	ProgramAddress *string `json:"programAddress,omitempty"`

	// SellerFeeBasisPoints DTO.TOKEN.EXTRA.SELLER_FEE_BASIS_POINTS
	SellerFeeBasisPoints *int64 `json:"sellerFeeBasisPoints,omitempty"`

	// TokenStandard DTO.TOKEN.EXTRA.TOKEN_STANDARD
	TokenStandard *string `json:"tokenStandard,omitempty"`

	// UpdateAuthority DTO.TOKEN.EXTRA.UPDATE_AUTHORITY
	UpdateAuthority *string `json:"updateAuthority,omitempty"`
}

// TokenHolder defines model for TokenHolder.
type TokenHolder struct {
	// Amount DTO.TOKEN_HOLDER.AMOUNT
	Amount string `json:"amount"`

	// AmountInUsd DTO.TOKEN_HOLDER.AMOUNT_USD
	AmountInUsd string `json:"amountInUsd"`

	// Percentage DTO.TOKEN_HOLDER.PERCENTAGE
	Percentage string `json:"percentage"`

	// WalletAddress DTO.TOKEN_HOLDER.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// TokenHolderPage defines model for TokenHolderPage.
type TokenHolderPage struct {
	// Data DTO.TOKEN_HOLDER.PAGE.DATA
	Data []TokenHolder `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TokenLiquiditySnapshotDTO defines model for TokenLiquiditySnapshotDTO.
type TokenLiquiditySnapshotDTO struct {
	// CalculatedAt DTO.TOKEN.LIQUIDITY_SNAPSHOT.CALCULATED_AT
	CalculatedAt int64 `json:"calculatedAt"`

	// MaxLiquidityInNative DTO.TOKEN.LIQUIDITY_SNAPSHOT.MAX_LIQUIDITY_IN_NATIVE
	MaxLiquidityInNative string `json:"maxLiquidityInNative"`

	// MaxLiquidityInUsd DTO.TOKEN.LIQUIDITY_SNAPSHOT.MAX_LIQUIDITY_IN_USD
	MaxLiquidityInUsd string `json:"maxLiquidityInUsd"`

	// MaxLiquidityPoolAddress DTO.TOKEN.LIQUIDITY_SNAPSHOT.MAX_LIQUIDITY_POOL_ADDRESS
	MaxLiquidityPoolAddress string `json:"maxLiquidityPoolAddress"`

	// PoolCount DTO.TOKEN.LIQUIDITY_SNAPSHOT.POOL_COUNT
	PoolCount int `json:"poolCount"`

	// PriceNative DTO.TOKEN.LIQUIDITY_SNAPSHOT.PRICE_NATIVE
	PriceNative string `json:"priceNative"`

	// PriceUsd DTO.TOKEN.LIQUIDITY_SNAPSHOT.PRICE_USD
	PriceUsd string `json:"priceUsd"`

	// SnapshotTime DTO.TOKEN.LIQUIDITY_SNAPSHOT.SNAPSHOT_TIME
	SnapshotTime int64 `json:"snapshotTime"`

	// TotalLiquidityInNative DTO.TOKEN.LIQUIDITY_SNAPSHOT.TOTAL_LIQUIDITY_IN_NATIVE
	TotalLiquidityInNative string `json:"totalLiquidityInNative"`

	// TotalLiquidityInUsd DTO.TOKEN.LIQUIDITY_SNAPSHOT.TOTAL_LIQUIDITY_IN_USD
	TotalLiquidityInUsd string `json:"totalLiquidityInUsd"`
}

// TokenLiquiditySnapshotPage defines model for TokenLiquiditySnapshotPage.
type TokenLiquiditySnapshotPage struct {
	// Data DTO.PAGE.DATA
	Data []TokenLiquiditySnapshotDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext bool `json:"hasNext"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev bool `json:"hasPrev"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`
}

// TokenListPage defines model for TokenListPage.
type TokenListPage struct {
	// Data DTO.TOKEN.PAGE.DATA
	Data []Token `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TokenMarketData defines model for TokenMarketData.
type TokenMarketData struct {
	// BluechipHoldingsRatio DTO.TOKEN.MARKET_CAP.BLUECHIP_HOLDINGS_RATIO
	BluechipHoldingsRatio *string `json:"bluechipHoldingsRatio,omitempty"`

	// BluechipTotalHolders DTO.TOKEN.MARKET_CAP.BLUECHIP_TOTAL_HOLDERS
	BluechipTotalHolders *string `json:"bluechipTotalHolders,omitempty"`

	// BluechipTotalHoldings DTO.TOKEN.MARKET_CAP.BLUECHIP_TOTAL_HOLDINGS
	BluechipTotalHoldings *string `json:"bluechipTotalHoldings,omitempty"`

	// BundleHoldingsRatio DTO.TOKEN.MARKET_CAP.BUNDLE_HOLDINGS_RATIO
	BundleHoldingsRatio *string `json:"bundleHoldingsRatio,omitempty"`

	// BundleTotalHolders DTO.TOKEN.MARKET_CAP.BUNDLE_TOTAL_HOLDERS
	BundleTotalHolders *string `json:"bundleTotalHolders,omitempty"`

	// BundleTotalHoldings DTO.TOKEN.MARKET_CAP.BUNDLE_TOTAL_HOLDINGS
	BundleTotalHoldings *string `json:"bundleTotalHoldings,omitempty"`

	// CompletionRatio DTO.TOKEN.MARKET_CAP.COMPLETION_RATIO
	CompletionRatio *string `json:"completionRatio,omitempty"`

	// DevHoldingsRatio DTO.TOKEN.MARKET_CAP.DEV_HOLDINGS_RATIO
	DevHoldingsRatio *string `json:"devHoldingsRatio,omitempty"`

	// DevTotalHolders DTO.TOKEN.MARKET_CAP.DEV_TOTAL_HOLDERS
	DevTotalHolders *string `json:"devTotalHolders,omitempty"`

	// DevTotalHoldings DTO.TOKEN.MARKET_CAP.DEV_TOTAL_HOLDINGS
	DevTotalHoldings *string `json:"devTotalHoldings,omitempty"`

	// FreshHoldingsRatio DTO.TOKEN.MARKET_CAP.FRESH_HOLDINGS_RATIO
	FreshHoldingsRatio *string `json:"freshHoldingsRatio,omitempty"`

	// FreshTotalHolders DTO.TOKEN.MARKET_CAP.FRESH_TOTAL_HOLDERS
	FreshTotalHolders *string `json:"freshTotalHolders,omitempty"`

	// FreshTotalHoldings DTO.TOKEN.MARKET_CAP.FRESH_TOTAL_HOLDINGS
	FreshTotalHoldings *string `json:"freshTotalHoldings,omitempty"`

	// Holders DTO.TOKEN.MARKET_CAP.HOLDERS
	Holders string `json:"holders"`

	// InsiderHoldingsRatio DTO.TOKEN.MARKET_CAP.INSIDER_HOLDINGS_RATIO
	InsiderHoldingsRatio *string `json:"insiderHoldingsRatio,omitempty"`

	// InsiderTotalHolders DTO.TOKEN.MARKET_CAP.INSIDER_TOTAL_HOLDERS
	InsiderTotalHolders *string `json:"insiderTotalHolders,omitempty"`

	// InsiderTotalHoldings DTO.TOKEN.MARKET_CAP.INSIDER_TOTAL_HOLDINGS
	InsiderTotalHoldings *string `json:"insiderTotalHoldings,omitempty"`

	// KolHoldingsRatio DTO.TOKEN.MARKET_CAP.KOL_HOLDINGS_RATIO
	KolHoldingsRatio *string `json:"kolHoldingsRatio,omitempty"`

	// KolTotalHolders DTO.TOKEN.MARKET_CAP.KOL_TOTAL_HOLDERS
	KolTotalHolders *string `json:"kolTotalHolders,omitempty"`

	// KolTotalHoldings DTO.TOKEN.MARKET_CAP.KOL_TOTAL_HOLDINGS
	KolTotalHoldings *string `json:"kolTotalHoldings,omitempty"`

	// MarketCapInSol DTO.TOKEN.MARKET_CAP.MARKET_CAP_IN_SOL
	MarketCapInSol *string `json:"marketCapInSol,omitempty"`

	// MarketCapInUsd DTO.TOKEN.MARKET_CAP.MARKET_CAP_IN_USD
	MarketCapInUsd string `json:"marketCapInUsd"`

	// MaxPoolTvlInSol DTO.TOKEN.MARKET_CAP.MAX_POOL_TVL_IN_SOL
	MaxPoolTvlInSol *string `json:"maxPoolTvlInSol,omitempty"`

	// MaxPoolTvlInUsd DTO.TOKEN.MARKET_CAP.MAX_POOL_TVL_IN_USD
	MaxPoolTvlInUsd *string `json:"maxPoolTvlInUsd,omitempty"`

	// PriceInSol DTO.TOKEN.MARKET_CAP.PRICE_IN_SOL
	PriceInSol *string `json:"priceInSol,omitempty"`

	// PriceInUsd DTO.TOKEN.MARKET_CAP.PRICE_IN_USD
	PriceInUsd string `json:"priceInUsd"`

	// ProHoldingsRatio DTO.TOKEN.MARKET_CAP.PRO_HOLDINGS_RATIO
	ProHoldingsRatio *string `json:"proHoldingsRatio,omitempty"`

	// ProTotalHolders DTO.TOKEN.MARKET_CAP.PRO_TOTAL_HOLDERS
	ProTotalHolders *string `json:"proTotalHolders,omitempty"`

	// ProTotalHoldings DTO.TOKEN.MARKET_CAP.PRO_TOTAL_HOLDINGS
	ProTotalHoldings *string `json:"proTotalHoldings,omitempty"`

	// SandwishHoldingsRatio DTO.TOKEN.MARKET_CAP.SANDWISH_HOLDINGS_RATIO
	SandwishHoldingsRatio *string `json:"sandwishHoldingsRatio,omitempty"`

	// SandwishTotalHolders DTO.TOKEN.MARKET_CAP.SANDWISH_TOTAL_HOLDERS
	SandwishTotalHolders *string `json:"sandwishTotalHolders,omitempty"`

	// SandwishTotalHoldings DTO.TOKEN.MARKET_CAP.SANDWISH_TOTAL_HOLDINGS
	SandwishTotalHoldings *string `json:"sandwishTotalHoldings,omitempty"`

	// SniperHoldingsRatio DTO.TOKEN.MARKET_CAP.SNIPER_HOLDINGS_RATIO
	SniperHoldingsRatio *string `json:"sniperHoldingsRatio,omitempty"`

	// SniperTotalHolders DTO.TOKEN.MARKET_CAP.SNIPER_TOTAL_HOLDERS
	SniperTotalHolders *string `json:"sniperTotalHolders,omitempty"`

	// SniperTotalHoldings DTO.TOKEN.MARKET_CAP.SNIPER_TOTAL_HOLDINGS
	SniperTotalHoldings *string `json:"sniperTotalHoldings,omitempty"`

	// Top100HoldingsRatio DTO.TOKEN.MARKET_CAP.TOP100_HOLDINGS_RATIO
	Top100HoldingsRatio *string `json:"top100HoldingsRatio,omitempty"`

	// Top100TotalHoldings DTO.TOKEN.MARKET_CAP.TOP100_TOTAL_HOLDINGS
	Top100TotalHoldings *string `json:"top100TotalHoldings,omitempty"`

	// Top10HoldingsRatio DTO.TOKEN.MARKET_CAP.TOP10_HOLDINGS_RATIO
	Top10HoldingsRatio *string `json:"top10HoldingsRatio,omitempty"`

	// Top10TotalHoldings DTO.TOKEN.MARKET_CAP.TOP10_TOTAL_HOLDINGS
	Top10TotalHoldings *string `json:"top10TotalHoldings,omitempty"`

	// Top50HoldingsRatio DTO.TOKEN.MARKET_CAP.TOP50_HOLDINGS_RATIO
	Top50HoldingsRatio *string `json:"top50HoldingsRatio,omitempty"`

	// Top50TotalHoldings DTO.TOKEN.MARKET_CAP.TOP50_TOTAL_HOLDINGS
	Top50TotalHoldings *string `json:"top50TotalHoldings,omitempty"`

	// TotalSupply DTO.TOKEN.MARKET_CAP.TOTAL_SUPPLY
	TotalSupply string `json:"totalSupply"`

	// TotalTvlInSol DTO.TOKEN.MARKET_CAP.TOTAL_TVL_IN_SOL
	TotalTvlInSol string `json:"totalTvlInSol"`

	// TotalTvlInUsd DTO.TOKEN.MARKET_CAP.TOTAL_TVL_IN_USD
	TotalTvlInUsd string `json:"totalTvlInUsd"`
}

// TokenMetadata defines model for TokenMetadata.
type TokenMetadata struct {
	// Address DTO.TOKEN.METADATA.ADDRESS
	Address string `json:"address"`

	// Chain DTO.TOKEN.METADATA.CHAIN
	Chain string `json:"chain"`

	// Decimals DTO.TOKEN.METADATA.DECIMALS
	Decimals int64 `json:"decimals"`

	// Description DTO.TOKEN.METADATA.DESCRIPTION
	Description *string `json:"description,omitempty"`

	// DevLastTokenCreatedAt DTO.TOKEN.METADATA.DEV_LAST_TOKEN_CREATED_AT
	DevLastTokenCreatedAt *string `json:"devLastTokenCreatedAt,omitempty"`

	// DevTotalTokens DTO.TOKEN.METADATA.DEV_TOTAL_TOKENS
	DevTotalTokens *string `json:"devTotalTokens,omitempty"`

	// Extra DTO.TOKEN.METADATA.EXTRA
	Extra *TokenExtraDTO `json:"extra,omitempty"`

	// ImageUrl DTO.TOKEN.METADATA.IMAGE_URL
	ImageUrl *string `json:"imageUrl,omitempty"`

	// MetadataAddress DTO.TOKEN.METADATA.METADATA_ADDRESS
	MetadataAddress *string `json:"metadataAddress,omitempty"`

	// Name DTO.TOKEN.METADATA.NAME
	Name string `json:"name"`

	// SocialMedias DTO.TOKEN.METADATA.SOCIAL_MEDIAS
	SocialMedias *TokenSocialMediasDTO `json:"socialMedias,omitempty"`

	// Symbol DTO.TOKEN.METADATA.SYMBOL
	Symbol string `json:"symbol"`

	// TokenCreatedAt DTO.TOKEN.METADATA.TOKEN_CREATED_AT
	TokenCreatedAt *int64 `json:"tokenCreatedAt,omitempty"`

	// TokenCreators DTO.TOKEN.METADATA.TOKEN_CREATORS
	TokenCreators *[]TokenCreatorsDTO `json:"tokenCreators,omitempty"`

	// Uri DTO.TOKEN.METADATA.URI
	Uri *string `json:"uri,omitempty"`
}

// TokenPage defines model for TokenPage.
type TokenPage struct {
	// CountsByProtocols DTO.TOKEN.PAGE.COUNTS_BY_PROTOCOLS
	CountsByProtocols *map[string]interface{} `json:"countsByProtocols,omitempty"`

	// Data DTO.TOKEN.PAGE.DATA
	Data []Token `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TokenPriceDTO defines model for TokenPriceDTO.
type TokenPriceDTO struct {
	// PriceInNative DTO.TOKEN.PRICE.PRICE_IN_NATIVE
	PriceInNative string `json:"priceInNative"`

	// PriceInUsd DTO.TOKEN.PRICE.PRICE_IN_USD
	PriceInUsd string `json:"priceInUsd"`

	// Timestamp DTO.TOKEN.PRICE.TIMESTAMP
	Timestamp int64 `json:"timestamp"`

	// TokenAddress DTO.TOKEN.PRICE.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`
}

// TokenPricePage defines model for TokenPricePage.
type TokenPricePage struct {
	// Data DTO.TOKEN.PRICE.PAGE.DATA
	Data []TokenPriceDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TokenSocialMediasDTO defines model for TokenSocialMediasDTO.
type TokenSocialMediasDTO struct {
	// Bitbucket DTO.TOKEN.SOCIAL_MEDIAS.BITBUCKET
	Bitbucket *string `json:"bitbucket,omitempty"`

	// Discord DTO.TOKEN.SOCIAL_MEDIAS.DISCORD
	Discord *string `json:"discord,omitempty"`

	// Facebook DTO.TOKEN.SOCIAL_MEDIAS.FACEBOOK
	Facebook *string `json:"facebook,omitempty"`

	// Github DTO.TOKEN.SOCIAL_MEDIAS.GITHUB
	Github *string `json:"github,omitempty"`

	// Instagram DTO.TOKEN.SOCIAL_MEDIAS.INSTAGRAM
	Instagram *string `json:"instagram,omitempty"`

	// Linkedin DTO.TOKEN.SOCIAL_MEDIAS.LINKEDIN
	Linkedin *string `json:"linkedin,omitempty"`

	// Medium DTO.TOKEN.SOCIAL_MEDIAS.MEDIUM
	Medium *string `json:"medium,omitempty"`

	// Reddit DTO.TOKEN.SOCIAL_MEDIAS.REDDIT
	Reddit *string `json:"reddit,omitempty"`

	// Telegram DTO.TOKEN.SOCIAL_MEDIAS.TELEGRAM
	Telegram *string `json:"telegram,omitempty"`

	// Tiktok DTO.TOKEN.SOCIAL_MEDIAS.TIKTOK
	Tiktok *string `json:"tiktok,omitempty"`

	// Twitter DTO.TOKEN.SOCIAL_MEDIAS.TWITTER
	Twitter *string `json:"twitter,omitempty"`

	// Website DTO.TOKEN.SOCIAL_MEDIAS.WEBSITE
	Website *string `json:"website,omitempty"`

	// Youtube DTO.TOKEN.SOCIAL_MEDIAS.YOUTUBE
	Youtube *string `json:"youtube,omitempty"`
}

// TokenStat defines model for TokenStat.
type TokenStat struct {
	// Address DTO.TOKEN.STAT.ADDRESS
	Address string `json:"address"`

	// BuyVolumes15m DTO.TOKEN.STAT.BUY_VOLUMES_15M
	BuyVolumes15m *string `json:"buyVolumes15m,omitempty"`

	// BuyVolumes1h DTO.TOKEN.STAT.BUY_VOLUMES_1H
	BuyVolumes1h string `json:"buyVolumes1h"`

	// BuyVolumes1m DTO.TOKEN.STAT.BUY_VOLUMES_1M
	BuyVolumes1m string `json:"buyVolumes1m"`

	// BuyVolumes24h DTO.TOKEN.STAT.BUY_VOLUMES_24H
	BuyVolumes24h string `json:"buyVolumes24h"`

	// BuyVolumes30m DTO.TOKEN.STAT.BUY_VOLUMES_30M
	BuyVolumes30m string `json:"buyVolumes30m"`

	// BuyVolumes4h DTO.TOKEN.STAT.BUY_VOLUMES_4H
	BuyVolumes4h string `json:"buyVolumes4h"`

	// BuyVolumes5m DTO.TOKEN.STAT.BUY_VOLUMES_5M
	BuyVolumes5m string `json:"buyVolumes5m"`

	// BuyVolumesInUsd15m DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_15M
	BuyVolumesInUsd15m *string `json:"buyVolumesInUsd15m,omitempty"`

	// BuyVolumesInUsd1h DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_1H
	BuyVolumesInUsd1h string `json:"buyVolumesInUsd1h"`

	// BuyVolumesInUsd1m DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_1M
	BuyVolumesInUsd1m string `json:"buyVolumesInUsd1m"`

	// BuyVolumesInUsd24h DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_24H
	BuyVolumesInUsd24h string `json:"buyVolumesInUsd24h"`

	// BuyVolumesInUsd30m DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_30M
	BuyVolumesInUsd30m string `json:"buyVolumesInUsd30m"`

	// BuyVolumesInUsd4h DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_4H
	BuyVolumesInUsd4h string `json:"buyVolumesInUsd4h"`

	// BuyVolumesInUsd5m DTO.TOKEN.STAT.BUY_VOLUMES_IN_USD_5M
	BuyVolumesInUsd5m string `json:"buyVolumesInUsd5m"`

	// Buyers15m DTO.TOKEN.STAT.BUYERS_15M
	Buyers15m *string `json:"buyers15m,omitempty"`

	// Buyers1h DTO.TOKEN.STAT.BUYERS_1H
	Buyers1h *string `json:"buyers1h,omitempty"`

	// Buyers1m DTO.TOKEN.STAT.BUYERS_1M
	Buyers1m *string `json:"buyers1m,omitempty"`

	// Buyers24h DTO.TOKEN.STAT.BUYERS_24H
	Buyers24h *string `json:"buyers24h,omitempty"`

	// Buyers30m DTO.TOKEN.STAT.BUYERS_30M
	Buyers30m *string `json:"buyers30m,omitempty"`

	// Buyers4h DTO.TOKEN.STAT.BUYERS_4H
	Buyers4h *string `json:"buyers4h,omitempty"`

	// Buyers5m DTO.TOKEN.STAT.BUYERS_5M
	Buyers5m *string `json:"buyers5m,omitempty"`

	// Buys15m DTO.TOKEN.STAT.BUYS_15M
	Buys15m *string `json:"buys15m,omitempty"`

	// Buys1h DTO.TOKEN.STAT.BUYS_1H
	Buys1h string `json:"buys1h"`

	// Buys1m DTO.TOKEN.STAT.BUYS_1M
	Buys1m string `json:"buys1m"`

	// Buys24h DTO.TOKEN.STAT.BUYS_24H
	Buys24h string `json:"buys24h"`

	// Buys30m DTO.TOKEN.STAT.BUYS_30M
	Buys30m string `json:"buys30m"`

	// Buys4h DTO.TOKEN.STAT.BUYS_4H
	Buys4h string `json:"buys4h"`

	// Buys5m DTO.TOKEN.STAT.BUYS_5M
	Buys5m string `json:"buys5m"`

	// ClosePriceInUsd15m DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_15M
	ClosePriceInUsd15m *string `json:"closePriceInUsd15m,omitempty"`

	// ClosePriceInUsd1h DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_1H
	ClosePriceInUsd1h string `json:"closePriceInUsd1h"`

	// ClosePriceInUsd1m DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_1M
	ClosePriceInUsd1m string `json:"closePriceInUsd1m"`

	// ClosePriceInUsd24h DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_24H
	ClosePriceInUsd24h string `json:"closePriceInUsd24h"`

	// ClosePriceInUsd30m DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_30M
	ClosePriceInUsd30m string `json:"closePriceInUsd30m"`

	// ClosePriceInUsd4h DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_4H
	ClosePriceInUsd4h string `json:"closePriceInUsd4h"`

	// ClosePriceInUsd5m DTO.TOKEN.STAT.CLOSE_PRICE_IN_USD_5M
	ClosePriceInUsd5m string `json:"closePriceInUsd5m"`

	// HighInUsd15m DTO.TOKEN.STAT.HIGH_IN_USD_15M
	HighInUsd15m *string `json:"highInUsd15m,omitempty"`

	// HighInUsd1h DTO.TOKEN.STAT.HIGH_IN_USD_1H
	HighInUsd1h *string `json:"highInUsd1h,omitempty"`

	// HighInUsd1m DTO.TOKEN.STAT.HIGH_IN_USD_1M
	HighInUsd1m *string `json:"highInUsd1m,omitempty"`

	// HighInUsd24h DTO.TOKEN.STAT.HIGH_IN_USD_24H
	HighInUsd24h *string `json:"highInUsd24h,omitempty"`

	// HighInUsd30m DTO.TOKEN.STAT.HIGH_IN_USD_30M
	HighInUsd30m *string `json:"highInUsd30m,omitempty"`

	// HighInUsd4h DTO.TOKEN.STAT.HIGH_IN_USD_4H
	HighInUsd4h *string `json:"highInUsd4h,omitempty"`

	// HighInUsd5m DTO.TOKEN.STAT.HIGH_IN_USD_5M
	HighInUsd5m *string `json:"highInUsd5m,omitempty"`

	// LowInUsd15m DTO.TOKEN.STAT.LOW_IN_USD_15M
	LowInUsd15m *string `json:"lowInUsd15m,omitempty"`

	// LowInUsd1h DTO.TOKEN.STAT.LOW_IN_USD_1H
	LowInUsd1h *string `json:"lowInUsd1h,omitempty"`

	// LowInUsd1m DTO.TOKEN.STAT.LOW_IN_USD_1M
	LowInUsd1m *string `json:"lowInUsd1m,omitempty"`

	// LowInUsd24h DTO.TOKEN.STAT.LOW_IN_USD_24H
	LowInUsd24h *string `json:"lowInUsd24h,omitempty"`

	// LowInUsd30m DTO.TOKEN.STAT.LOW_IN_USD_30M
	LowInUsd30m *string `json:"lowInUsd30m,omitempty"`

	// LowInUsd4h DTO.TOKEN.STAT.LOW_IN_USD_4H
	LowInUsd4h *string `json:"lowInUsd4h,omitempty"`

	// LowInUsd5m DTO.TOKEN.STAT.LOW_IN_USD_5M
	LowInUsd5m *string `json:"lowInUsd5m,omitempty"`

	// OpenPriceInUsd15m DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_15M
	OpenPriceInUsd15m *string `json:"openPriceInUsd15m,omitempty"`

	// OpenPriceInUsd1h DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_1H
	OpenPriceInUsd1h string `json:"openPriceInUsd1h"`

	// OpenPriceInUsd1m DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_1M
	OpenPriceInUsd1m string `json:"openPriceInUsd1m"`

	// OpenPriceInUsd24h DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_24H
	OpenPriceInUsd24h string `json:"openPriceInUsd24h"`

	// OpenPriceInUsd30m DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_30M
	OpenPriceInUsd30m string `json:"openPriceInUsd30m"`

	// OpenPriceInUsd4h DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_4H
	OpenPriceInUsd4h string `json:"openPriceInUsd4h"`

	// OpenPriceInUsd5m DTO.TOKEN.STAT.OPEN_PRICE_IN_USD_5M
	OpenPriceInUsd5m string `json:"openPriceInUsd5m"`

	// Price15m DTO.TOKEN.STAT.PRICE_15M
	Price15m *string `json:"price15m,omitempty"`

	// Price1h DTO.TOKEN.STAT.PRICE_1H
	Price1h string `json:"price1h"`

	// Price1m DTO.TOKEN.STAT.PRICE_1M
	Price1m string `json:"price1m"`

	// Price24h DTO.TOKEN.STAT.PRICE_24H
	Price24h string `json:"price24h"`

	// Price30m DTO.TOKEN.STAT.PRICE_30M
	Price30m string `json:"price30m"`

	// Price4h DTO.TOKEN.STAT.PRICE_4H
	Price4h string `json:"price4h"`

	// Price5m DTO.TOKEN.STAT.PRICE_5M
	Price5m string `json:"price5m"`

	// PriceChangeRatioInUsd15m DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_15M
	PriceChangeRatioInUsd15m *string `json:"priceChangeRatioInUsd15m,omitempty"`

	// PriceChangeRatioInUsd1h DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_1H
	PriceChangeRatioInUsd1h string `json:"priceChangeRatioInUsd1h"`

	// PriceChangeRatioInUsd1m DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_1M
	PriceChangeRatioInUsd1m string `json:"priceChangeRatioInUsd1m"`

	// PriceChangeRatioInUsd24h DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_24H
	PriceChangeRatioInUsd24h string `json:"priceChangeRatioInUsd24h"`

	// PriceChangeRatioInUsd30m DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_30M
	PriceChangeRatioInUsd30m string `json:"priceChangeRatioInUsd30m"`

	// PriceChangeRatioInUsd4h DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_4H
	PriceChangeRatioInUsd4h string `json:"priceChangeRatioInUsd4h"`

	// PriceChangeRatioInUsd5m DTO.TOKEN.STAT.PRICE_CHANGE_RATIO_IN_USD_5M
	PriceChangeRatioInUsd5m string `json:"priceChangeRatioInUsd5m"`

	// SellVolumesInUsd15m DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_15M
	SellVolumesInUsd15m *string `json:"sellVolumesInUsd15m,omitempty"`

	// SellVolumesInUsd1h DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_1H
	SellVolumesInUsd1h string `json:"sellVolumesInUsd1h"`

	// SellVolumesInUsd1m DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_1M
	SellVolumesInUsd1m string `json:"sellVolumesInUsd1m"`

	// SellVolumesInUsd24h DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_24H
	SellVolumesInUsd24h string `json:"sellVolumesInUsd24h"`

	// SellVolumesInUsd30m DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_30M
	SellVolumesInUsd30m string `json:"sellVolumesInUsd30m"`

	// SellVolumesInUsd4h DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_4H
	SellVolumesInUsd4h string `json:"sellVolumesInUsd4h"`

	// SellVolumesInUsd5m DTO.TOKEN.STAT.SELL_VOLUMES_IN_USD_5M
	SellVolumesInUsd5m string `json:"sellVolumesInUsd5m"`

	// Sellers15m DTO.TOKEN.STAT.SELLERS_15M
	Sellers15m *string `json:"sellers15m,omitempty"`

	// Sellers1h DTO.TOKEN.STAT.SELLERS_1H
	Sellers1h *string `json:"sellers1h,omitempty"`

	// Sellers1m DTO.TOKEN.STAT.SELLERS_1M
	Sellers1m *string `json:"sellers1m,omitempty"`

	// Sellers24h DTO.TOKEN.STAT.SELLERS_24H
	Sellers24h *string `json:"sellers24h,omitempty"`

	// Sellers30m DTO.TOKEN.STAT.SELLERS_30M
	Sellers30m *string `json:"sellers30m,omitempty"`

	// Sellers4h DTO.TOKEN.STAT.SELLERS_4H
	Sellers4h *string `json:"sellers4h,omitempty"`

	// Sellers5m DTO.TOKEN.STAT.SELLERS_5M
	Sellers5m *string `json:"sellers5m,omitempty"`

	// Sells15m DTO.TOKEN.STAT.SELLS_15M
	Sells15m *string `json:"sells15m,omitempty"`

	// Sells1h DTO.TOKEN.STAT.SELLS_1H
	Sells1h string `json:"sells1h"`

	// Sells1m DTO.TOKEN.STAT.SELLS_1M
	Sells1m string `json:"sells1m"`

	// Sells24h DTO.TOKEN.STAT.SELLS_24H
	Sells24h string `json:"sells24h"`

	// Sells30m DTO.TOKEN.STAT.SELLS_30M
	Sells30m string `json:"sells30m"`

	// Sells4h DTO.TOKEN.STAT.SELLS_4H
	Sells4h string `json:"sells4h"`

	// Sells5m DTO.TOKEN.STAT.SELLS_5M
	Sells5m string `json:"sells5m"`

	// SellsVolumes15m DTO.TOKEN.STAT.SELL_VOLUMES_15M
	SellsVolumes15m *string `json:"sellsVolumes15m,omitempty"`

	// SellsVolumes1h DTO.TOKEN.STAT.SELL_VOLUMES_1H
	SellsVolumes1h string `json:"sellsVolumes1h"`

	// SellsVolumes1m DTO.TOKEN.STAT.SELL_VOLUMES_1M
	SellsVolumes1m string `json:"sellsVolumes1m"`

	// SellsVolumes24h DTO.TOKEN.STAT.SELL_VOLUMES_24H
	SellsVolumes24h string `json:"sellsVolumes24h"`

	// SellsVolumes30m DTO.TOKEN.STAT.SELL_VOLUMES_30M
	SellsVolumes30m string `json:"sellsVolumes30m"`

	// SellsVolumes4h DTO.TOKEN.STAT.SELL_VOLUMES_4H
	SellsVolumes4h string `json:"sellsVolumes4h"`

	// SellsVolumes5m DTO.TOKEN.STAT.SELL_VOLUMES_5M
	SellsVolumes5m string `json:"sellsVolumes5m"`

	// Traders15m DTO.TOKEN.STAT.TRADERS_15M
	Traders15m *string `json:"traders15m,omitempty"`

	// Traders1h DTO.TOKEN.STAT.TRADERS_1H
	Traders1h *string `json:"traders1h,omitempty"`

	// Traders1m DTO.TOKEN.STAT.TRADERS_1M
	Traders1m *string `json:"traders1m,omitempty"`

	// Traders24h DTO.TOKEN.STAT.TRADERS_24H
	Traders24h *string `json:"traders24h,omitempty"`

	// Traders30m DTO.TOKEN.STAT.TRADERS_30M
	Traders30m *string `json:"traders30m,omitempty"`

	// Traders4h DTO.TOKEN.STAT.TRADERS_4H
	Traders4h *string `json:"traders4h,omitempty"`

	// Traders5m DTO.TOKEN.STAT.TRADERS_5M
	Traders5m *string `json:"traders5m,omitempty"`

	// Trades15m DTO.TOKEN.STAT.TRADES_15M
	Trades15m *string `json:"trades15m,omitempty"`

	// Trades1h DTO.TOKEN.STAT.TRADES_1H
	Trades1h string `json:"trades1h"`

	// Trades1m DTO.TOKEN.STAT.TRADES_1M
	Trades1m string `json:"trades1m"`

	// Trades24h DTO.TOKEN.STAT.TRADES_24H
	Trades24h string `json:"trades24h"`

	// Trades30m DTO.TOKEN.STAT.TRADES_30M
	Trades30m string `json:"trades30m"`

	// Trades4h DTO.TOKEN.STAT.TRADES_4H
	Trades4h string `json:"trades4h"`

	// Trades5m DTO.TOKEN.STAT.TRADES_5M
	Trades5m string `json:"trades5m"`

	// Volumes15m DTO.TOKEN.STAT.VOLUMES_15M
	Volumes15m *string `json:"volumes15m,omitempty"`

	// Volumes1h DTO.TOKEN.STAT.VOLUMES_1H
	Volumes1h string `json:"volumes1h"`

	// Volumes1m DTO.TOKEN.STAT.VOLUMES_1M
	Volumes1m string `json:"volumes1m"`

	// Volumes24h DTO.TOKEN.STAT.VOLUMES_24H
	Volumes24h string `json:"volumes24h"`

	// Volumes30m DTO.TOKEN.STAT.VOLUMES_30M
	Volumes30m string `json:"volumes30m"`

	// Volumes4h DTO.TOKEN.STAT.VOLUMES_4H
	Volumes4h string `json:"volumes4h"`

	// Volumes5m DTO.TOKEN.STAT.VOLUMES_5M
	Volumes5m string `json:"volumes5m"`

	// VolumesInUsd15m DTO.TOKEN.STAT.VOLUMES_IN_USD_15M
	VolumesInUsd15m *string `json:"volumesInUsd15m,omitempty"`

	// VolumesInUsd1h DTO.TOKEN.STAT.VOLUMES_IN_USD_1H
	VolumesInUsd1h string `json:"volumesInUsd1h"`

	// VolumesInUsd1m DTO.TOKEN.STAT.VOLUMES_IN_USD_1M
	VolumesInUsd1m string `json:"volumesInUsd1m"`

	// VolumesInUsd24h DTO.TOKEN.STAT.VOLUMES_IN_USD_24H
	VolumesInUsd24h string `json:"volumesInUsd24h"`

	// VolumesInUsd30m DTO.TOKEN.STAT.VOLUMES_IN_USD_30M
	VolumesInUsd30m string `json:"volumesInUsd30m"`

	// VolumesInUsd4h DTO.TOKEN.STAT.VOLUMES_IN_USD_4H
	VolumesInUsd4h string `json:"volumesInUsd4h"`

	// VolumesInUsd5m DTO.TOKEN.STAT.VOLUMES_IN_USD_5M
	VolumesInUsd5m string `json:"volumesInUsd5m"`
}

// TokenTrader defines model for TokenTrader.
type TokenTrader struct {
	// Address DTO.TOKEN_TRADER.ADDRESS
	Address string `json:"address"`

	// BlockHash DTO.TOKEN_TRADER.BLOCK_HASH
	BlockHash *string `json:"blockHash,omitempty"`

	// BlockHeight DTO.TOKEN_TRADER.BLOCK_HEIGHT
	BlockHeight *int64 `json:"blockHeight,omitempty"`

	// BlockSlot DTO.TOKEN_TRADER.BLOCK_SLOT
	BlockSlot *int64 `json:"blockSlot,omitempty"`

	// BlockTimestamp DTO.TOKEN_TRADER.BLOCK_TIMESTAMP
	BlockTimestamp *time.Time `json:"blockTimestamp,omitempty"`

	// OnchainCreatedAt DTO.TOKEN_TRADER.ONCHAIN_CREATED_AT
	OnchainCreatedAt *map[string]interface{} `json:"onchainCreatedAt,omitempty"`

	// PercentileRankTradeAmountInUsd DTO.TOKEN_TRADER.PERCENTILE_RANK_TRADE_AMOUNT_IN_USD
	PercentileRankTradeAmountInUsd *string `json:"percentileRankTradeAmountInUsd,omitempty"`

	// PercentileRankTradeCount DTO.TOKEN_TRADER.PERCENTILE_RANK_TRADE_COUNT
	PercentileRankTradeCount *int64 `json:"percentileRankTradeCount,omitempty"`

	// RankTradeAmountInUsd DTO.TOKEN_TRADER.RANK_TRADE_AMOUNT_IN_USD
	RankTradeAmountInUsd *string `json:"rankTradeAmountInUsd,omitempty"`

	// TradeAmountInNative DTO.TOKEN_TRADER.TRADE_AMOUNT_IN_NATIVE
	TradeAmountInNative *string `json:"tradeAmountInNative,omitempty"`

	// TradeAmountInUsd DTO.TOKEN_TRADER.TRADE_AMOUNT_IN_USD
	TradeAmountInUsd *string `json:"tradeAmountInUsd,omitempty"`

	// TradeCount DTO.TOKEN_TRADER.TRADE_COUNT
	TradeCount *int64 `json:"tradeCount,omitempty"`

	// TransactionSignature DTO.TOKEN_TRADER.TRANSACTION_SIGNATURE
	TransactionSignature *string `json:"transactionSignature,omitempty"`
}

// TokenTraderTag defines model for TokenTraderTag.
type TokenTraderTag string

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Chains DTO.TOKEN.SEARCH.CHAINS
	Chains *[]string `form:"chains,omitempty" json:"chains,omitempty"`

	// Q DTO.TOKEN.SEARCH.QUERY
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Limit DTO.TOKEN.SEARCH.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort DTO.TOKEN.SEARCH.SORT_DIRECTION
	Sort *SearchParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Protocols DTO.TOKEN.SEARCH.PROTOCOLS
	Protocols *[]string `form:"protocols,omitempty" json:"protocols,omitempty"`

	// Cursor DTO.PAGE.CURSOR
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SortBy DTO.TOKEN.SEARCH.SORT_BY
	SortBy *SearchParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`
}

// SearchParamsSort defines parameters for Search.
type SearchParamsSort string

// SearchParamsSortBy defines parameters for Search.
type SearchParamsSortBy string

// ListTokenParams defines parameters for ListToken.
type ListTokenParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *ListTokenParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Sort DTO.TOKEN.SEARCH.SORT_DIRECTION
	Sort *ListTokenParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SortBy DTO.TOKEN.LIST.QUERY.SORT_BY
	SortBy *ListTokenParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// MinH24VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H24_VOLUME_IN_USD
	MinH24VolumeInUsd *string `form:"min_h24_volume_in_usd,omitempty" json:"min_h24_volume_in_usd,omitempty"`

	// MaxH24VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H24_VOLUME_IN_USD
	MaxH24VolumeInUsd *string `form:"max_h24_volume_in_usd,omitempty" json:"max_h24_volume_in_usd,omitempty"`

	// MinH24PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_H24_PRICE_CHANGE_RATIO
	MinH24PriceChangeRatio *string `form:"min_h24_price_change_ratio,omitempty" json:"min_h24_price_change_ratio,omitempty"`

	// MaxH24PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_H24_PRICE_CHANGE_RATIO
	MaxH24PriceChangeRatio *string `form:"max_h24_price_change_ratio,omitempty" json:"max_h24_price_change_ratio,omitempty"`

	// MinH24Buys DTO.TOKEN.LIST.QUERY.MIN_H24_BUYS
	MinH24Buys *string `form:"min_h24_buys,omitempty" json:"min_h24_buys,omitempty"`

	// MaxH24Buys DTO.TOKEN.LIST.QUERY.MAX_H24_BUYS
	MaxH24Buys *string `form:"max_h24_buys,omitempty" json:"max_h24_buys,omitempty"`

	// MinH24Sells DTO.TOKEN.LIST.QUERY.MIN_H24_SELLS
	MinH24Sells *string `form:"min_h24_sells,omitempty" json:"min_h24_sells,omitempty"`

	// MaxH24Sells DTO.TOKEN.LIST.QUERY.MAX_H24_SELLS
	MaxH24Sells *string `form:"max_h24_sells,omitempty" json:"max_h24_sells,omitempty"`

	// MinH24Trades DTO.TOKEN.LIST.QUERY.MIN_H24_TRADES
	MinH24Trades *string `form:"min_h24_trades,omitempty" json:"min_h24_trades,omitempty"`

	// MaxH24Trades DTO.TOKEN.LIST.QUERY.MAX_H24_TRADES
	MaxH24Trades *string `form:"max_h24_trades,omitempty" json:"max_h24_trades,omitempty"`

	// MinH24Buyers DTO.TOKEN.LIST.QUERY.MIN_H24_BUYERS
	MinH24Buyers *string `form:"min_h24_buyers,omitempty" json:"min_h24_buyers,omitempty"`

	// MaxH24Buyers DTO.TOKEN.LIST.QUERY.MAX_H24_BUYERS
	MaxH24Buyers *string `form:"max_h24_buyers,omitempty" json:"max_h24_buyers,omitempty"`

	// MinH24Sellers DTO.TOKEN.LIST.QUERY.MIN_H24_SELLERS
	MinH24Sellers *string `form:"min_h24_sellers,omitempty" json:"min_h24_sellers,omitempty"`

	// MaxH24Sellers DTO.TOKEN.LIST.QUERY.MAX_H24_SELLERS
	MaxH24Sellers *string `form:"max_h24_sellers,omitempty" json:"max_h24_sellers,omitempty"`

	// MinH24BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H24_BUY_VOLUME_IN_USD
	MinH24BuyVolumeInUsd *string `form:"min_h24_buy_volume_in_usd,omitempty" json:"min_h24_buy_volume_in_usd,omitempty"`

	// MaxH24BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H24_BUY_VOLUME_IN_USD
	MaxH24BuyVolumeInUsd *string `form:"max_h24_buy_volume_in_usd,omitempty" json:"max_h24_buy_volume_in_usd,omitempty"`

	// MinH24SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H24_SELL_VOLUME_IN_USD
	MinH24SellVolumeInUsd *string `form:"min_h24_sell_volume_in_usd,omitempty" json:"min_h24_sell_volume_in_usd,omitempty"`

	// MaxH24SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H24_SELL_VOLUME_IN_USD
	MaxH24SellVolumeInUsd *string `form:"max_h24_sell_volume_in_usd,omitempty" json:"max_h24_sell_volume_in_usd,omitempty"`

	// MinH4VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H4_VOLUME_IN_USD
	MinH4VolumeInUsd *string `form:"min_h4_volume_in_usd,omitempty" json:"min_h4_volume_in_usd,omitempty"`

	// MaxH4VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H4_VOLUME_IN_USD
	MaxH4VolumeInUsd *string `form:"max_h4_volume_in_usd,omitempty" json:"max_h4_volume_in_usd,omitempty"`

	// MinH4PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_H4_PRICE_CHANGE_RATIO
	MinH4PriceChangeRatio *string `form:"min_h4_price_change_ratio,omitempty" json:"min_h4_price_change_ratio,omitempty"`

	// MaxH4PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_H4_PRICE_CHANGE_RATIO
	MaxH4PriceChangeRatio *string `form:"max_h4_price_change_ratio,omitempty" json:"max_h4_price_change_ratio,omitempty"`

	// MinH4Buys DTO.TOKEN.LIST.QUERY.MIN_H4_BUYS
	MinH4Buys *string `form:"min_h4_buys,omitempty" json:"min_h4_buys,omitempty"`

	// MaxH4Buys DTO.TOKEN.LIST.QUERY.MAX_H4_BUYS
	MaxH4Buys *string `form:"max_h4_buys,omitempty" json:"max_h4_buys,omitempty"`

	// MinH4Sells DTO.TOKEN.LIST.QUERY.MIN_H4_SELLS
	MinH4Sells *string `form:"min_h4_sells,omitempty" json:"min_h4_sells,omitempty"`

	// MaxH4Sells DTO.TOKEN.LIST.QUERY.MAX_H4_SELLS
	MaxH4Sells *string `form:"max_h4_sells,omitempty" json:"max_h4_sells,omitempty"`

	// MinH4Trades DTO.TOKEN.LIST.QUERY.MIN_H4_TRADES
	MinH4Trades *string `form:"min_h4_trades,omitempty" json:"min_h4_trades,omitempty"`

	// MaxH4Trades DTO.TOKEN.LIST.QUERY.MAX_H4_TRADES
	MaxH4Trades *string `form:"max_h4_trades,omitempty" json:"max_h4_trades,omitempty"`

	// MinH4Buyers DTO.TOKEN.LIST.QUERY.MIN_H4_BUYERS
	MinH4Buyers *string `form:"min_h4_buyers,omitempty" json:"min_h4_buyers,omitempty"`

	// MaxH4Buyers DTO.TOKEN.LIST.QUERY.MAX_H4_BUYERS
	MaxH4Buyers *string `form:"max_h4_buyers,omitempty" json:"max_h4_buyers,omitempty"`

	// MinH4Sellers DTO.TOKEN.LIST.QUERY.MIN_H4_SELLERS
	MinH4Sellers *string `form:"min_h4_sellers,omitempty" json:"min_h4_sellers,omitempty"`

	// MaxH4Sellers DTO.TOKEN.LIST.QUERY.MAX_H4_SELLERS
	MaxH4Sellers *string `form:"max_h4_sellers,omitempty" json:"max_h4_sellers,omitempty"`

	// MinH4BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H4_BUY_VOLUME_IN_USD
	MinH4BuyVolumeInUsd *string `form:"min_h4_buy_volume_in_usd,omitempty" json:"min_h4_buy_volume_in_usd,omitempty"`

	// MaxH4BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H4_BUY_VOLUME_IN_USD
	MaxH4BuyVolumeInUsd *string `form:"max_h4_buy_volume_in_usd,omitempty" json:"max_h4_buy_volume_in_usd,omitempty"`

	// MinH4SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H4_SELL_VOLUME_IN_USD
	MinH4SellVolumeInUsd *string `form:"min_h4_sell_volume_in_usd,omitempty" json:"min_h4_sell_volume_in_usd,omitempty"`

	// MaxH4SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H4_SELL_VOLUME_IN_USD
	MaxH4SellVolumeInUsd *string `form:"max_h4_sell_volume_in_usd,omitempty" json:"max_h4_sell_volume_in_usd,omitempty"`

	// MinH1VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H1_VOLUME_IN_USD
	MinH1VolumeInUsd *string `form:"min_h1_volume_in_usd,omitempty" json:"min_h1_volume_in_usd,omitempty"`

	// MaxH1VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H1_VOLUME_IN_USD
	MaxH1VolumeInUsd *string `form:"max_h1_volume_in_usd,omitempty" json:"max_h1_volume_in_usd,omitempty"`

	// MinH1PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_H1_PRICE_CHANGE_RATIO
	MinH1PriceChangeRatio *string `form:"min_h1_price_change_ratio,omitempty" json:"min_h1_price_change_ratio,omitempty"`

	// MaxH1PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_H1_PRICE_CHANGE_RATIO
	MaxH1PriceChangeRatio *string `form:"max_h1_price_change_ratio,omitempty" json:"max_h1_price_change_ratio,omitempty"`

	// MinH1Buys DTO.TOKEN.LIST.QUERY.MIN_H1_BUYS
	MinH1Buys *string `form:"min_h1_buys,omitempty" json:"min_h1_buys,omitempty"`

	// MaxH1Buys DTO.TOKEN.LIST.QUERY.MAX_H1_BUYS
	MaxH1Buys *string `form:"max_h1_buys,omitempty" json:"max_h1_buys,omitempty"`

	// MinH1Sells DTO.TOKEN.LIST.QUERY.MIN_H1_SELLS
	MinH1Sells *string `form:"min_h1_sells,omitempty" json:"min_h1_sells,omitempty"`

	// MaxH1Sells DTO.TOKEN.LIST.QUERY.MAX_H1_SELLS
	MaxH1Sells *string `form:"max_h1_sells,omitempty" json:"max_h1_sells,omitempty"`

	// MinH1Trades DTO.TOKEN.LIST.QUERY.MIN_H1_TRADES
	MinH1Trades *string `form:"min_h1_trades,omitempty" json:"min_h1_trades,omitempty"`

	// MaxH1Trades DTO.TOKEN.LIST.QUERY.MAX_H1_TRADES
	MaxH1Trades *string `form:"max_h1_trades,omitempty" json:"max_h1_trades,omitempty"`

	// MinH1Buyers DTO.TOKEN.LIST.QUERY.MIN_H1_BUYERS
	MinH1Buyers *string `form:"min_h1_buyers,omitempty" json:"min_h1_buyers,omitempty"`

	// MaxH1Buyers DTO.TOKEN.LIST.QUERY.MAX_H1_BUYERS
	MaxH1Buyers *string `form:"max_h1_buyers,omitempty" json:"max_h1_buyers,omitempty"`

	// MinH1Sellers DTO.TOKEN.LIST.QUERY.MIN_H1_SELLERS
	MinH1Sellers *string `form:"min_h1_sellers,omitempty" json:"min_h1_sellers,omitempty"`

	// MaxH1Sellers DTO.TOKEN.LIST.QUERY.MAX_H1_SELLERS
	MaxH1Sellers *string `form:"max_h1_sellers,omitempty" json:"max_h1_sellers,omitempty"`

	// MinH1BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H1_BUY_VOLUME_IN_USD
	MinH1BuyVolumeInUsd *string `form:"min_h1_buy_volume_in_usd,omitempty" json:"min_h1_buy_volume_in_usd,omitempty"`

	// MaxH1BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H1_BUY_VOLUME_IN_USD
	MaxH1BuyVolumeInUsd *string `form:"max_h1_buy_volume_in_usd,omitempty" json:"max_h1_buy_volume_in_usd,omitempty"`

	// MinH1SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_H1_SELL_VOLUME_IN_USD
	MinH1SellVolumeInUsd *string `form:"min_h1_sell_volume_in_usd,omitempty" json:"min_h1_sell_volume_in_usd,omitempty"`

	// MaxH1SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_H1_SELL_VOLUME_IN_USD
	MaxH1SellVolumeInUsd *string `form:"max_h1_sell_volume_in_usd,omitempty" json:"max_h1_sell_volume_in_usd,omitempty"`

	// MinM30VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M30_VOLUME_IN_USD
	MinM30VolumeInUsd *string `form:"min_m30_volume_in_usd,omitempty" json:"min_m30_volume_in_usd,omitempty"`

	// MaxM30VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M30_VOLUME_IN_USD
	MaxM30VolumeInUsd *string `form:"max_m30_volume_in_usd,omitempty" json:"max_m30_volume_in_usd,omitempty"`

	// MinM30PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_M30_PRICE_CHANGE_RATIO
	MinM30PriceChangeRatio *string `form:"min_m30_price_change_ratio,omitempty" json:"min_m30_price_change_ratio,omitempty"`

	// MaxM30PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_M30_PRICE_CHANGE_RATIO
	MaxM30PriceChangeRatio *string `form:"max_m30_price_change_ratio,omitempty" json:"max_m30_price_change_ratio,omitempty"`

	// MinM30Buys DTO.TOKEN.LIST.QUERY.MIN_M30_BUYS
	MinM30Buys *string `form:"min_m30_buys,omitempty" json:"min_m30_buys,omitempty"`

	// MaxM30Buys DTO.TOKEN.LIST.QUERY.MAX_M30_BUYS
	MaxM30Buys *string `form:"max_m30_buys,omitempty" json:"max_m30_buys,omitempty"`

	// MinM30Sells DTO.TOKEN.LIST.QUERY.MIN_M30_SELLS
	MinM30Sells *string `form:"min_m30_sells,omitempty" json:"min_m30_sells,omitempty"`

	// MaxM30Sells DTO.TOKEN.LIST.QUERY.MAX_M30_SELLS
	MaxM30Sells *string `form:"max_m30_sells,omitempty" json:"max_m30_sells,omitempty"`

	// MinM30Trades DTO.TOKEN.LIST.QUERY.MIN_M30_TRADES
	MinM30Trades *string `form:"min_m30_trades,omitempty" json:"min_m30_trades,omitempty"`

	// MaxM30Trades DTO.TOKEN.LIST.QUERY.MAX_M30_TRADES
	MaxM30Trades *string `form:"max_m30_trades,omitempty" json:"max_m30_trades,omitempty"`

	// MinM30Buyers DTO.TOKEN.LIST.QUERY.MIN_M30_BUYERS
	MinM30Buyers *string `form:"min_m30_buyers,omitempty" json:"min_m30_buyers,omitempty"`

	// MaxM30Buyers DTO.TOKEN.LIST.QUERY.MAX_M30_BUYERS
	MaxM30Buyers *string `form:"max_m30_buyers,omitempty" json:"max_m30_buyers,omitempty"`

	// MinM30Sellers DTO.TOKEN.LIST.QUERY.MIN_M30_SELLERS
	MinM30Sellers *string `form:"min_m30_sellers,omitempty" json:"min_m30_sellers,omitempty"`

	// MaxM30Sellers DTO.TOKEN.LIST.QUERY.MAX_M30_SELLERS
	MaxM30Sellers *string `form:"max_m30_sellers,omitempty" json:"max_m30_sellers,omitempty"`

	// MinM30BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M30_BUY_VOLUME_IN_USD
	MinM30BuyVolumeInUsd *string `form:"min_m30_buy_volume_in_usd,omitempty" json:"min_m30_buy_volume_in_usd,omitempty"`

	// MaxM30BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M30_BUY_VOLUME_IN_USD
	MaxM30BuyVolumeInUsd *string `form:"max_m30_buy_volume_in_usd,omitempty" json:"max_m30_buy_volume_in_usd,omitempty"`

	// MinM30SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M30_SELL_VOLUME_IN_USD
	MinM30SellVolumeInUsd *string `form:"min_m30_sell_volume_in_usd,omitempty" json:"min_m30_sell_volume_in_usd,omitempty"`

	// MaxM30SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M30_SELL_VOLUME_IN_USD
	MaxM30SellVolumeInUsd *string `form:"max_m30_sell_volume_in_usd,omitempty" json:"max_m30_sell_volume_in_usd,omitempty"`

	// MinM15VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M15_VOLUME_IN_USD
	MinM15VolumeInUsd *string `form:"min_m15_volume_in_usd,omitempty" json:"min_m15_volume_in_usd,omitempty"`

	// MaxM15VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M15_VOLUME_IN_USD
	MaxM15VolumeInUsd *string `form:"max_m15_volume_in_usd,omitempty" json:"max_m15_volume_in_usd,omitempty"`

	// MinM15PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_M15_PRICE_CHANGE_RATIO
	MinM15PriceChangeRatio *string `form:"min_m15_price_change_ratio,omitempty" json:"min_m15_price_change_ratio,omitempty"`

	// MaxM15PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_M15_PRICE_CHANGE_RATIO
	MaxM15PriceChangeRatio *string `form:"max_m15_price_change_ratio,omitempty" json:"max_m15_price_change_ratio,omitempty"`

	// MinM15Buys DTO.TOKEN.LIST.QUERY.MIN_M15_BUYS
	MinM15Buys *string `form:"min_m15_buys,omitempty" json:"min_m15_buys,omitempty"`

	// MaxM15Buys DTO.TOKEN.LIST.QUERY.MAX_M15_BUYS
	MaxM15Buys *string `form:"max_m15_buys,omitempty" json:"max_m15_buys,omitempty"`

	// MinM15Sells DTO.TOKEN.LIST.QUERY.MIN_M15_SELLS
	MinM15Sells *string `form:"min_m15_sells,omitempty" json:"min_m15_sells,omitempty"`

	// MaxM15Sells DTO.TOKEN.LIST.QUERY.MAX_M15_SELLS
	MaxM15Sells *string `form:"max_m15_sells,omitempty" json:"max_m15_sells,omitempty"`

	// MinM15Trades DTO.TOKEN.LIST.QUERY.MIN_M15_TRADES
	MinM15Trades *string `form:"min_m15_trades,omitempty" json:"min_m15_trades,omitempty"`

	// MaxM15Trades DTO.TOKEN.LIST.QUERY.MAX_M15_TRADES
	MaxM15Trades *string `form:"max_m15_trades,omitempty" json:"max_m15_trades,omitempty"`

	// MinM15Buyers DTO.TOKEN.LIST.QUERY.MIN_M15_BUYERS
	MinM15Buyers *string `form:"min_m15_buyers,omitempty" json:"min_m15_buyers,omitempty"`

	// MaxM15Buyers DTO.TOKEN.LIST.QUERY.MAX_M15_BUYERS
	MaxM15Buyers *string `form:"max_m15_buyers,omitempty" json:"max_m15_buyers,omitempty"`

	// MinM15Sellers DTO.TOKEN.LIST.QUERY.MIN_M15_SELLERS
	MinM15Sellers *string `form:"min_m15_sellers,omitempty" json:"min_m15_sellers,omitempty"`

	// MaxM15Sellers DTO.TOKEN.LIST.QUERY.MAX_M15_SELLERS
	MaxM15Sellers *string `form:"max_m15_sellers,omitempty" json:"max_m15_sellers,omitempty"`

	// MinM15BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M15_BUY_VOLUME_IN_USD
	MinM15BuyVolumeInUsd *string `form:"min_m15_buy_volume_in_usd,omitempty" json:"min_m15_buy_volume_in_usd,omitempty"`

	// MaxM15BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M15_BUY_VOLUME_IN_USD
	MaxM15BuyVolumeInUsd *string `form:"max_m15_buy_volume_in_usd,omitempty" json:"max_m15_buy_volume_in_usd,omitempty"`

	// MinM15SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M15_SELL_VOLUME_IN_USD
	MinM15SellVolumeInUsd *string `form:"min_m15_sell_volume_in_usd,omitempty" json:"min_m15_sell_volume_in_usd,omitempty"`

	// MaxM15SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M15_SELL_VOLUME_IN_USD
	MaxM15SellVolumeInUsd *string `form:"max_m15_sell_volume_in_usd,omitempty" json:"max_m15_sell_volume_in_usd,omitempty"`

	// MinM5VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M5_VOLUME_IN_USD
	MinM5VolumeInUsd *string `form:"min_m5_volume_in_usd,omitempty" json:"min_m5_volume_in_usd,omitempty"`

	// MaxM5VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M5_VOLUME_IN_USD
	MaxM5VolumeInUsd *string `form:"max_m5_volume_in_usd,omitempty" json:"max_m5_volume_in_usd,omitempty"`

	// MinM5PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_M5_PRICE_CHANGE_RATIO
	MinM5PriceChangeRatio *string `form:"min_m5_price_change_ratio,omitempty" json:"min_m5_price_change_ratio,omitempty"`

	// MaxM5PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_M5_PRICE_CHANGE_RATIO
	MaxM5PriceChangeRatio *string `form:"max_m5_price_change_ratio,omitempty" json:"max_m5_price_change_ratio,omitempty"`

	// MinM5Buys DTO.TOKEN.LIST.QUERY.MIN_M5_BUYS
	MinM5Buys *string `form:"min_m5_buys,omitempty" json:"min_m5_buys,omitempty"`

	// MaxM5Buys DTO.TOKEN.LIST.QUERY.MAX_M5_BUYS
	MaxM5Buys *string `form:"max_m5_buys,omitempty" json:"max_m5_buys,omitempty"`

	// MinM5Sells DTO.TOKEN.LIST.QUERY.MIN_M5_SELLS
	MinM5Sells *string `form:"min_m5_sells,omitempty" json:"min_m5_sells,omitempty"`

	// MaxM5Sells DTO.TOKEN.LIST.QUERY.MAX_M5_SELLS
	MaxM5Sells *string `form:"max_m5_sells,omitempty" json:"max_m5_sells,omitempty"`

	// MinM5Trades DTO.TOKEN.LIST.QUERY.MIN_M5_TRADES
	MinM5Trades *string `form:"min_m5_trades,omitempty" json:"min_m5_trades,omitempty"`

	// MaxM5Trades DTO.TOKEN.LIST.QUERY.MAX_M5_TRADES
	MaxM5Trades *string `form:"max_m5_trades,omitempty" json:"max_m5_trades,omitempty"`

	// MinM5Buyers DTO.TOKEN.LIST.QUERY.MIN_M5_BUYERS
	MinM5Buyers *string `form:"min_m5_buyers,omitempty" json:"min_m5_buyers,omitempty"`

	// MaxM5Buyers DTO.TOKEN.LIST.QUERY.MAX_M5_BUYERS
	MaxM5Buyers *string `form:"max_m5_buyers,omitempty" json:"max_m5_buyers,omitempty"`

	// MinM5Sellers DTO.TOKEN.LIST.QUERY.MIN_M5_SELLERS
	MinM5Sellers *string `form:"min_m5_sellers,omitempty" json:"min_m5_sellers,omitempty"`

	// MaxM5Sellers DTO.TOKEN.LIST.QUERY.MAX_M5_SELLERS
	MaxM5Sellers *string `form:"max_m5_sellers,omitempty" json:"max_m5_sellers,omitempty"`

	// MinM5BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M5_BUY_VOLUME_IN_USD
	MinM5BuyVolumeInUsd *string `form:"min_m5_buy_volume_in_usd,omitempty" json:"min_m5_buy_volume_in_usd,omitempty"`

	// MaxM5BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M5_BUY_VOLUME_IN_USD
	MaxM5BuyVolumeInUsd *string `form:"max_m5_buy_volume_in_usd,omitempty" json:"max_m5_buy_volume_in_usd,omitempty"`

	// MinM5SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M5_SELL_VOLUME_IN_USD
	MinM5SellVolumeInUsd *string `form:"min_m5_sell_volume_in_usd,omitempty" json:"min_m5_sell_volume_in_usd,omitempty"`

	// MaxM5SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M5_SELL_VOLUME_IN_USD
	MaxM5SellVolumeInUsd *string `form:"max_m5_sell_volume_in_usd,omitempty" json:"max_m5_sell_volume_in_usd,omitempty"`

	// MinM1VolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M1_VOLUME_IN_USD
	MinM1VolumeInUsd *string `form:"min_m1_volume_in_usd,omitempty" json:"min_m1_volume_in_usd,omitempty"`

	// MaxM1VolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M1_VOLUME_IN_USD
	MaxM1VolumeInUsd *string `form:"max_m1_volume_in_usd,omitempty" json:"max_m1_volume_in_usd,omitempty"`

	// MinM1PriceChangeRatio DTO.TOKEN.LIST.QUERY.MIN_M1_PRICE_CHANGE_RATIO
	MinM1PriceChangeRatio *string `form:"min_m1_price_change_ratio,omitempty" json:"min_m1_price_change_ratio,omitempty"`

	// MaxM1PriceChangeRatio DTO.TOKEN.LIST.QUERY.MAX_M1_PRICE_CHANGE_RATIO
	MaxM1PriceChangeRatio *string `form:"max_m1_price_change_ratio,omitempty" json:"max_m1_price_change_ratio,omitempty"`

	// MinM1Buys DTO.TOKEN.LIST.QUERY.MIN_M1_BUYS
	MinM1Buys *string `form:"min_m1_buys,omitempty" json:"min_m1_buys,omitempty"`

	// MaxM1Buys DTO.TOKEN.LIST.QUERY.MAX_M1_BUYS
	MaxM1Buys *string `form:"max_m1_buys,omitempty" json:"max_m1_buys,omitempty"`

	// MinM1Sells DTO.TOKEN.LIST.QUERY.MIN_M1_SELLS
	MinM1Sells *string `form:"min_m1_sells,omitempty" json:"min_m1_sells,omitempty"`

	// MaxM1Sells DTO.TOKEN.LIST.QUERY.MAX_M1_SELLS
	MaxM1Sells *string `form:"max_m1_sells,omitempty" json:"max_m1_sells,omitempty"`

	// MinM1Trades DTO.TOKEN.LIST.QUERY.MIN_M1_TRADES
	MinM1Trades *string `form:"min_m1_trades,omitempty" json:"min_m1_trades,omitempty"`

	// MaxM1Trades DTO.TOKEN.LIST.QUERY.MAX_M1_TRADES
	MaxM1Trades *string `form:"max_m1_trades,omitempty" json:"max_m1_trades,omitempty"`

	// MinM1Buyers DTO.TOKEN.LIST.QUERY.MIN_M1_BUYERS
	MinM1Buyers *string `form:"min_m1_buyers,omitempty" json:"min_m1_buyers,omitempty"`

	// MaxM1Buyers DTO.TOKEN.LIST.QUERY.MAX_M1_BUYERS
	MaxM1Buyers *string `form:"max_m1_buyers,omitempty" json:"max_m1_buyers,omitempty"`

	// MinM1Sellers DTO.TOKEN.LIST.QUERY.MIN_M1_SELLERS
	MinM1Sellers *string `form:"min_m1_sellers,omitempty" json:"min_m1_sellers,omitempty"`

	// MaxM1Sellers DTO.TOKEN.LIST.QUERY.MAX_M1_SELLERS
	MaxM1Sellers *string `form:"max_m1_sellers,omitempty" json:"max_m1_sellers,omitempty"`

	// MinM1BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M1_BUY_VOLUME_IN_USD
	MinM1BuyVolumeInUsd *string `form:"min_m1_buy_volume_in_usd,omitempty" json:"min_m1_buy_volume_in_usd,omitempty"`

	// MaxM1BuyVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M1_BUY_VOLUME_IN_USD
	MaxM1BuyVolumeInUsd *string `form:"max_m1_buy_volume_in_usd,omitempty" json:"max_m1_buy_volume_in_usd,omitempty"`

	// MinM1SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MIN_M1_SELL_VOLUME_IN_USD
	MinM1SellVolumeInUsd *string `form:"min_m1_sell_volume_in_usd,omitempty" json:"min_m1_sell_volume_in_usd,omitempty"`

	// MaxM1SellVolumeInUsd DTO.TOKEN.LIST.QUERY.MAX_M1_SELL_VOLUME_IN_USD
	MaxM1SellVolumeInUsd *string `form:"max_m1_sell_volume_in_usd,omitempty" json:"max_m1_sell_volume_in_usd,omitempty"`
}

// ListTokenParamsDirection defines parameters for ListToken.
type ListTokenParamsDirection string

// ListTokenParamsSort defines parameters for ListToken.
type ListTokenParamsSort string

// ListTokenParamsSortBy defines parameters for ListToken.
type ListTokenParamsSortBy string

// GetMarketDataMultiParams defines parameters for GetMarketDataMulti.
type GetMarketDataMultiParams struct {
	// TokenAddresses GLOBAL.TOKENADDRESSES.DESCRIPTION
	TokenAddresses string `form:"tokenAddresses" json:"tokenAddresses"`
}

// GetMetadataMultiParams defines parameters for GetMetadataMulti.
type GetMetadataMultiParams struct {
	// TokenAddresses GLOBAL.TOKENADDRESSES.DESCRIPTION
	TokenAddresses string `form:"tokenAddresses" json:"tokenAddresses"`
}

// GetTokensParams defines parameters for GetTokens.
type GetTokensParams struct {
	// TokenAddresses GLOBAL.TOKENADDRESSES.DESCRIPTION
	TokenAddresses string `form:"tokenAddresses" json:"tokenAddresses"`

	// SortBy DTO.TOKEN.REQUEST.SORT_BY
	SortBy *GetTokensParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection DTO.TOKEN.REQUEST.SORT_DIRECTION
	SortDirection *GetTokensParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// FilterBy DTO.TOKEN.REQUEST.FILTER_BY
	FilterBy *[]FilterCondition `form:"filterBy,omitempty" json:"filterBy,omitempty"`
}

// GetTokensParamsSortBy defines parameters for GetTokens.
type GetTokensParamsSortBy string

// GetTokensParamsSortDirection defines parameters for GetTokens.
type GetTokensParamsSortDirection string

// GetStatsMultiParams defines parameters for GetStatsMulti.
type GetStatsMultiParams struct {
	// TokenAddresses GLOBAL.TOKENADDRESSES.DESCRIPTION
	TokenAddresses string `form:"tokenAddresses" json:"tokenAddresses"`
}

// GetCandlesParams defines parameters for GetCandles.
type GetCandlesParams struct {
	// Resolution DTO.CANDLE.RESOLUTION
	Resolution Resolution `form:"resolution" json:"resolution"`

	// From DTO.CANDLE.FROM
	From *int64 `form:"from,omitempty" json:"from,omitempty"`

	// To DTO.CANDLE.TO
	To *int64 `form:"to,omitempty" json:"to,omitempty"`

	// Limit DTO.CANDLE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetHoldersParams defines parameters for GetHolders.
type GetHoldersParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetHoldersParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetHoldersParamsDirection defines parameters for GetHolders.
type GetHoldersParamsDirection string

// GetHoldersMultiParams defines parameters for GetHoldersMulti.
type GetHoldersMultiParams struct {
	// WalletAddresses GLOBAL.WALLETADDRESSES.DESCRIPTION
	WalletAddresses string `form:"walletAddresses" json:"walletAddresses"`
}

// GetTokenLiquiditySnapshotsParams defines parameters for GetTokenLiquiditySnapshots.
type GetTokenLiquiditySnapshotsParams struct {
	// Time DTO.TOKEN.LIQUIDITY_SNAPSHOT.TIME
	Time *int64 `form:"time,omitempty" json:"time,omitempty"`

	// Cursor DTO.PAGE.CURSOR
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMintAndBurnParams defines parameters for GetMintAndBurn.
type GetMintAndBurnParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetMintAndBurnParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Type DTO.TOKEN.MINT_AND_BURN.TYPE
	Type *GetMintAndBurnParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetMintAndBurnParamsDirection defines parameters for GetMintAndBurn.
type GetMintAndBurnParamsDirection string

// GetMintAndBurnParamsType defines parameters for GetMintAndBurn.
type GetMintAndBurnParamsType string

// GetPoolsParams defines parameters for GetPools.
type GetPoolsParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetPoolsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// SortBy DTO.POOL.SORT_BY
	SortBy *GetPoolsParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection DTO.POOL.SORT_DIRECTION
	SortDirection *GetPoolsParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// MinTvlInSol DTO.POOL.MIN_TVL_IN_SOL
	MinTvlInSol *string `form:"minTvlInSol,omitempty" json:"minTvlInSol,omitempty"`

	// MaxTvlInSol DTO.POOL.MAX_TVL_IN_SOL
	MaxTvlInSol *string `form:"maxTvlInSol,omitempty" json:"maxTvlInSol,omitempty"`

	// MinTvlInUsd DTO.POOL.MIN_TVL_IN_USD
	MinTvlInUsd *string `form:"minTvlInUsd,omitempty" json:"minTvlInUsd,omitempty"`

	// MaxTvlInUsd DTO.POOL.MAX_TVL_IN_USD
	MaxTvlInUsd *string `form:"maxTvlInUsd,omitempty" json:"maxTvlInUsd,omitempty"`
}

// GetPoolsParamsDirection defines parameters for GetPools.
type GetPoolsParamsDirection string

// GetPoolsParamsSortBy defines parameters for GetPools.
type GetPoolsParamsSortBy string

// GetPoolsParamsSortDirection defines parameters for GetPools.
type GetPoolsParamsSortDirection string

// GetPriceByTimeParams defines parameters for GetPriceByTime.
type GetPriceByTimeParams struct {
	// Timestamp DTO.TOKEN.PRICE.QUERY.TIMESTAMP
	Timestamp int64 `form:"timestamp" json:"timestamp"`
}

// GetPricesParams defines parameters for GetPrices.
type GetPricesParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetPricesParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetPricesParamsDirection defines parameters for GetPrices.
type GetPricesParamsDirection string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevTokens request
	GetDevTokens(ctx context.Context, chain ChainSymbol, devAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListToken request
	ListToken(ctx context.Context, chain ChainSymbol, params *ListTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketDataMulti request
	GetMarketDataMulti(ctx context.Context, chain ChainSymbol, params *GetMarketDataMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataMulti request
	GetMetadataMulti(ctx context.Context, chain ChainSymbol, params *GetMetadataMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokens request
	GetTokens(ctx context.Context, chain ChainSymbol, params *GetTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsMulti request
	GetStatsMulti(ctx context.Context, chain ChainSymbol, params *GetStatsMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetToken request
	GetToken(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCandles request
	GetCandles(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCreation request
	GetCreation(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHolders request
	GetHolders(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHoldersMulti request
	GetHoldersMulti(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenLiquiditySnapshots request
	GetTokenLiquiditySnapshots(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetTokenLiquiditySnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarketData request
	GetMarketData(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadata request
	GetMetadata(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMintAndBurn request
	GetMintAndBurn(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetMintAndBurnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPools request
	GetPools(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceByTime request
	GetPriceByTime(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPriceByTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrices request
	GetPrices(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurity request
	GetSecurity(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopHolders request
	GetTopHolders(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenTraders request
	GetTokenTraders(ctx context.Context, chain ChainSymbol, tokenAddress string, tag TokenTraderTag, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevTokens(ctx context.Context, chain ChainSymbol, devAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDevTokensRequest(c.Server, chain, devAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListToken(ctx context.Context, chain ChainSymbol, params *ListTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokenRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketDataMulti(ctx context.Context, chain ChainSymbol, params *GetMarketDataMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketDataMultiRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataMulti(ctx context.Context, chain ChainSymbol, params *GetMetadataMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataMultiRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokens(ctx context.Context, chain ChainSymbol, params *GetTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatsMulti(ctx context.Context, chain ChainSymbol, params *GetStatsMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsMultiRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetToken(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCandles(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetCandlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCandlesRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCreation(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreationRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHolders(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHoldersRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHoldersMulti(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersMultiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHoldersMultiRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenLiquiditySnapshots(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetTokenLiquiditySnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenLiquiditySnapshotsRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarketData(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketDataRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadata(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMintAndBurn(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetMintAndBurnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMintAndBurnRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPools(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoolsRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceByTime(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPriceByTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceByTimeRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrices(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricesRequest(c.Server, chain, tokenAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurity(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopHolders(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopHoldersRequest(c.Server, chain, tokenAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenTraders(ctx context.Context, chain ChainSymbol, tokenAddress string, tag TokenTraderTag, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenTradersRequest(c.Server, chain, tokenAddress, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Chains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chains", runtime.ParamLocationQuery, *params.Chains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Protocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protocols", runtime.ParamLocationQuery, *params.Protocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDevTokensRequest generates requests for GetDevTokens
func NewGetDevTokensRequest(server string, chain ChainSymbol, devAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "devAddress", runtime.ParamLocationPath, devAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/dev/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokenRequest generates requests for ListToken
func NewListTokenRequest(server string, chain ChainSymbol, params *ListTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_volume_in_usd", runtime.ParamLocationQuery, *params.MinH24VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH24VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_price_change_ratio", runtime.ParamLocationQuery, *params.MinH24PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_price_change_ratio", runtime.ParamLocationQuery, *params.MaxH24PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_buys", runtime.ParamLocationQuery, *params.MinH24Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_buys", runtime.ParamLocationQuery, *params.MaxH24Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_sells", runtime.ParamLocationQuery, *params.MinH24Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_sells", runtime.ParamLocationQuery, *params.MaxH24Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_trades", runtime.ParamLocationQuery, *params.MinH24Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_trades", runtime.ParamLocationQuery, *params.MaxH24Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_buyers", runtime.ParamLocationQuery, *params.MinH24Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_buyers", runtime.ParamLocationQuery, *params.MaxH24Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_sellers", runtime.ParamLocationQuery, *params.MinH24Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_sellers", runtime.ParamLocationQuery, *params.MaxH24Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinH24BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH24BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH24SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h24_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinH24SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH24SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h24_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH24SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_volume_in_usd", runtime.ParamLocationQuery, *params.MinH4VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH4VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_price_change_ratio", runtime.ParamLocationQuery, *params.MinH4PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_price_change_ratio", runtime.ParamLocationQuery, *params.MaxH4PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_buys", runtime.ParamLocationQuery, *params.MinH4Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_buys", runtime.ParamLocationQuery, *params.MaxH4Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_sells", runtime.ParamLocationQuery, *params.MinH4Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_sells", runtime.ParamLocationQuery, *params.MaxH4Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_trades", runtime.ParamLocationQuery, *params.MinH4Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_trades", runtime.ParamLocationQuery, *params.MaxH4Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_buyers", runtime.ParamLocationQuery, *params.MinH4Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_buyers", runtime.ParamLocationQuery, *params.MaxH4Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_sellers", runtime.ParamLocationQuery, *params.MinH4Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_sellers", runtime.ParamLocationQuery, *params.MaxH4Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinH4BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH4BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH4SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h4_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinH4SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH4SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h4_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH4SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_volume_in_usd", runtime.ParamLocationQuery, *params.MinH1VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH1VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_price_change_ratio", runtime.ParamLocationQuery, *params.MinH1PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_price_change_ratio", runtime.ParamLocationQuery, *params.MaxH1PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_buys", runtime.ParamLocationQuery, *params.MinH1Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_buys", runtime.ParamLocationQuery, *params.MaxH1Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_sells", runtime.ParamLocationQuery, *params.MinH1Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_sells", runtime.ParamLocationQuery, *params.MaxH1Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_trades", runtime.ParamLocationQuery, *params.MinH1Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_trades", runtime.ParamLocationQuery, *params.MaxH1Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_buyers", runtime.ParamLocationQuery, *params.MinH1Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_buyers", runtime.ParamLocationQuery, *params.MaxH1Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_sellers", runtime.ParamLocationQuery, *params.MinH1Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_sellers", runtime.ParamLocationQuery, *params.MaxH1Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinH1BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH1BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinH1SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_h1_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinH1SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxH1SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_h1_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxH1SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_volume_in_usd", runtime.ParamLocationQuery, *params.MinM30VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM30VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_price_change_ratio", runtime.ParamLocationQuery, *params.MinM30PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_price_change_ratio", runtime.ParamLocationQuery, *params.MaxM30PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_buys", runtime.ParamLocationQuery, *params.MinM30Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_buys", runtime.ParamLocationQuery, *params.MaxM30Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_sells", runtime.ParamLocationQuery, *params.MinM30Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_sells", runtime.ParamLocationQuery, *params.MaxM30Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_trades", runtime.ParamLocationQuery, *params.MinM30Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_trades", runtime.ParamLocationQuery, *params.MaxM30Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_buyers", runtime.ParamLocationQuery, *params.MinM30Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_buyers", runtime.ParamLocationQuery, *params.MaxM30Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_sellers", runtime.ParamLocationQuery, *params.MinM30Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_sellers", runtime.ParamLocationQuery, *params.MaxM30Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinM30BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM30BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM30SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m30_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinM30SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM30SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m30_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM30SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_volume_in_usd", runtime.ParamLocationQuery, *params.MinM15VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM15VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_price_change_ratio", runtime.ParamLocationQuery, *params.MinM15PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_price_change_ratio", runtime.ParamLocationQuery, *params.MaxM15PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_buys", runtime.ParamLocationQuery, *params.MinM15Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_buys", runtime.ParamLocationQuery, *params.MaxM15Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_sells", runtime.ParamLocationQuery, *params.MinM15Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_sells", runtime.ParamLocationQuery, *params.MaxM15Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_trades", runtime.ParamLocationQuery, *params.MinM15Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_trades", runtime.ParamLocationQuery, *params.MaxM15Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_buyers", runtime.ParamLocationQuery, *params.MinM15Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_buyers", runtime.ParamLocationQuery, *params.MaxM15Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_sellers", runtime.ParamLocationQuery, *params.MinM15Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_sellers", runtime.ParamLocationQuery, *params.MaxM15Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinM15BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM15BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM15SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m15_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinM15SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM15SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m15_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM15SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_volume_in_usd", runtime.ParamLocationQuery, *params.MinM5VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM5VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_price_change_ratio", runtime.ParamLocationQuery, *params.MinM5PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_price_change_ratio", runtime.ParamLocationQuery, *params.MaxM5PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_buys", runtime.ParamLocationQuery, *params.MinM5Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_buys", runtime.ParamLocationQuery, *params.MaxM5Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_sells", runtime.ParamLocationQuery, *params.MinM5Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_sells", runtime.ParamLocationQuery, *params.MaxM5Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_trades", runtime.ParamLocationQuery, *params.MinM5Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_trades", runtime.ParamLocationQuery, *params.MaxM5Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_buyers", runtime.ParamLocationQuery, *params.MinM5Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_buyers", runtime.ParamLocationQuery, *params.MaxM5Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_sellers", runtime.ParamLocationQuery, *params.MinM5Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_sellers", runtime.ParamLocationQuery, *params.MaxM5Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinM5BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM5BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM5SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m5_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinM5SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM5SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m5_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM5SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_volume_in_usd", runtime.ParamLocationQuery, *params.MinM1VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1VolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM1VolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_price_change_ratio", runtime.ParamLocationQuery, *params.MinM1PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1PriceChangeRatio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_price_change_ratio", runtime.ParamLocationQuery, *params.MaxM1PriceChangeRatio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_buys", runtime.ParamLocationQuery, *params.MinM1Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1Buys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_buys", runtime.ParamLocationQuery, *params.MaxM1Buys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_sells", runtime.ParamLocationQuery, *params.MinM1Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1Sells != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_sells", runtime.ParamLocationQuery, *params.MaxM1Sells); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_trades", runtime.ParamLocationQuery, *params.MinM1Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1Trades != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_trades", runtime.ParamLocationQuery, *params.MaxM1Trades); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_buyers", runtime.ParamLocationQuery, *params.MinM1Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1Buyers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_buyers", runtime.ParamLocationQuery, *params.MaxM1Buyers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_sellers", runtime.ParamLocationQuery, *params.MinM1Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1Sellers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_sellers", runtime.ParamLocationQuery, *params.MaxM1Sellers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MinM1BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1BuyVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_buy_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM1BuyVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinM1SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_m1_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MinM1SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxM1SellVolumeInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_m1_sell_volume_in_usd", runtime.ParamLocationQuery, *params.MaxM1SellVolumeInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketDataMultiRequest generates requests for GetMarketDataMulti
func NewGetMarketDataMultiRequest(server string, chain ChainSymbol, params *GetMarketDataMultiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/marketData/multi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddresses", runtime.ParamLocationQuery, params.TokenAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataMultiRequest generates requests for GetMetadataMulti
func NewGetMetadataMultiRequest(server string, chain ChainSymbol, params *GetMetadataMultiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/metadata/multi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddresses", runtime.ParamLocationQuery, params.TokenAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokensRequest generates requests for GetTokens
func NewGetTokensRequest(server string, chain ChainSymbol, params *GetTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/multi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddresses", runtime.ParamLocationQuery, params.TokenAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterBy", runtime.ParamLocationQuery, *params.FilterBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsMultiRequest generates requests for GetStatsMulti
func NewGetStatsMultiRequest(server string, chain ChainSymbol, params *GetStatsMultiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/stats/multi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddresses", runtime.ParamLocationQuery, params.TokenAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenRequest generates requests for GetToken
func NewGetTokenRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCandlesRequest generates requests for GetCandles
func NewGetCandlesRequest(server string, chain ChainSymbol, tokenAddress string, params *GetCandlesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/candles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreationRequest generates requests for GetCreation
func NewGetCreationRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/creation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHoldersRequest generates requests for GetHolders
func NewGetHoldersRequest(server string, chain ChainSymbol, tokenAddress string, params *GetHoldersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/holders", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHoldersMultiRequest generates requests for GetHoldersMulti
func NewGetHoldersMultiRequest(server string, chain ChainSymbol, tokenAddress string, params *GetHoldersMultiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/holders/multi", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walletAddresses", runtime.ParamLocationQuery, params.WalletAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenLiquiditySnapshotsRequest generates requests for GetTokenLiquiditySnapshots
func NewGetTokenLiquiditySnapshotsRequest(server string, chain ChainSymbol, tokenAddress string, params *GetTokenLiquiditySnapshotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/liquiditySnapshots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketDataRequest generates requests for GetMarketData
func NewGetMarketDataRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/marketData", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataRequest generates requests for GetMetadata
func NewGetMetadataRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMintAndBurnRequest generates requests for GetMintAndBurn
func NewGetMintAndBurnRequest(server string, chain ChainSymbol, tokenAddress string, params *GetMintAndBurnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/mintAndBurn", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPoolsRequest generates requests for GetPools
func NewGetPoolsRequest(server string, chain ChainSymbol, tokenAddress string, params *GetPoolsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/pools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTvlInSol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minTvlInSol", runtime.ParamLocationQuery, *params.MinTvlInSol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTvlInSol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxTvlInSol", runtime.ParamLocationQuery, *params.MaxTvlInSol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTvlInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minTvlInUsd", runtime.ParamLocationQuery, *params.MinTvlInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTvlInUsd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxTvlInUsd", runtime.ParamLocationQuery, *params.MaxTvlInUsd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPriceByTimeRequest generates requests for GetPriceByTime
func NewGetPriceByTimeRequest(server string, chain ChainSymbol, tokenAddress string, params *GetPriceByTimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/price", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timestamp", runtime.ParamLocationQuery, params.Timestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricesRequest generates requests for GetPrices
func NewGetPricesRequest(server string, chain ChainSymbol, tokenAddress string, params *GetPricesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/prices", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityRequest generates requests for GetSecurity
func NewGetSecurityRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/security", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/stats", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopHoldersRequest generates requests for GetTopHolders
func NewGetTopHoldersRequest(server string, chain ChainSymbol, tokenAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/topHolders", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenTradersRequest generates requests for GetTokenTraders
func NewGetTokenTradersRequest(server string, chain ChainSymbol, tokenAddress string, tag TokenTraderTag) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenAddress", runtime.ParamLocationPath, tokenAddress)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/token/%s/%s/traders/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// GetDevTokensWithResponse request
	GetDevTokensWithResponse(ctx context.Context, chain ChainSymbol, devAddress string, reqEditors ...RequestEditorFn) (*GetDevTokensResponse, error)

	// ListTokenWithResponse request
	ListTokenWithResponse(ctx context.Context, chain ChainSymbol, params *ListTokenParams, reqEditors ...RequestEditorFn) (*ListTokenResponse, error)

	// GetMarketDataMultiWithResponse request
	GetMarketDataMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetMarketDataMultiParams, reqEditors ...RequestEditorFn) (*GetMarketDataMultiResponse, error)

	// GetMetadataMultiWithResponse request
	GetMetadataMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetMetadataMultiParams, reqEditors ...RequestEditorFn) (*GetMetadataMultiResponse, error)

	// GetTokensWithResponse request
	GetTokensWithResponse(ctx context.Context, chain ChainSymbol, params *GetTokensParams, reqEditors ...RequestEditorFn) (*GetTokensResponse, error)

	// GetStatsMultiWithResponse request
	GetStatsMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetStatsMultiParams, reqEditors ...RequestEditorFn) (*GetStatsMultiResponse, error)

	// GetTokenWithResponse request
	GetTokenWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error)

	// GetCandlesWithResponse request
	GetCandlesWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetCandlesParams, reqEditors ...RequestEditorFn) (*GetCandlesResponse, error)

	// GetCreationWithResponse request
	GetCreationWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetCreationResponse, error)

	// GetHoldersWithResponse request
	GetHoldersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersParams, reqEditors ...RequestEditorFn) (*GetHoldersResponse, error)

	// GetHoldersMultiWithResponse request
	GetHoldersMultiWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersMultiParams, reqEditors ...RequestEditorFn) (*GetHoldersMultiResponse, error)

	// GetTokenLiquiditySnapshotsWithResponse request
	GetTokenLiquiditySnapshotsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetTokenLiquiditySnapshotsParams, reqEditors ...RequestEditorFn) (*GetTokenLiquiditySnapshotsResponse, error)

	// GetMarketDataWithResponse request
	GetMarketDataWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetMarketDataResponse, error)

	// GetMetadataWithResponse request
	GetMetadataWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetMetadataResponse, error)

	// GetMintAndBurnWithResponse request
	GetMintAndBurnWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetMintAndBurnParams, reqEditors ...RequestEditorFn) (*GetMintAndBurnResponse, error)

	// GetPoolsWithResponse request
	GetPoolsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*GetPoolsResponse, error)

	// GetPriceByTimeWithResponse request
	GetPriceByTimeWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPriceByTimeParams, reqEditors ...RequestEditorFn) (*GetPriceByTimeResponse, error)

	// GetPricesWithResponse request
	GetPricesWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*GetPricesResponse, error)

	// GetSecurityWithResponse request
	GetSecurityWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetSecurityResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetTopHoldersWithResponse request
	GetTopHoldersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetTopHoldersResponse, error)

	// GetTokenTradersWithResponse request
	GetTokenTradersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, tag TokenTraderTag, reqEditors ...RequestEditorFn) (*GetTokenTradersResponse, error)
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPage
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDevTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DevTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetDevTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDevTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenListPage
}

// Status returns HTTPResponse.Status
func (r ListTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketDataMultiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]TokenMarketData
}

// Status returns HTTPResponse.Status
func (r GetMarketDataMultiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketDataMultiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataMultiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]TokenMetadata
}

// Status returns HTTPResponse.Status
func (r GetMetadataMultiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataMultiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Token
}

// Status returns HTTPResponse.Status
func (r GetTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsMultiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]TokenStat
}

// Status returns HTTPResponse.Status
func (r GetStatsMultiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsMultiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token
}

// Status returns HTTPResponse.Status
func (r GetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCandlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Candle
}

// Status returns HTTPResponse.Status
func (r GetCandlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCandlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenCreationDTO
}

// Status returns HTTPResponse.Status
func (r GetCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenHolderPage
}

// Status returns HTTPResponse.Status
func (r GetHoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHoldersMultiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TokenHolder
}

// Status returns HTTPResponse.Status
func (r GetHoldersMultiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHoldersMultiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenLiquiditySnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenLiquiditySnapshotPage
}

// Status returns HTTPResponse.Status
func (r GetTokenLiquiditySnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenLiquiditySnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenMarketData
}

// Status returns HTTPResponse.Status
func (r GetMarketDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenMetadata
}

// Status returns HTTPResponse.Status
func (r GetMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMintAndBurnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenCreationPage
}

// Status returns HTTPResponse.Status
func (r GetMintAndBurnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMintAndBurnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DexPoolPage
}

// Status returns HTTPResponse.Status
func (r GetPoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceByTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPriceDTO
}

// Status returns HTTPResponse.Status
func (r GetPriceByTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceByTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPricePage
}

// Status returns HTTPResponse.Status
func (r GetPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetSecurityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenStat
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopHoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenHolderPage
}

// Status returns HTTPResponse.Status
func (r GetTopHoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopHoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenTradersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TokenTrader
}

// Status returns HTTPResponse.Status
func (r GetTokenTradersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenTradersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// GetDevTokensWithResponse request returning *GetDevTokensResponse
func (c *ClientWithResponses) GetDevTokensWithResponse(ctx context.Context, chain ChainSymbol, devAddress string, reqEditors ...RequestEditorFn) (*GetDevTokensResponse, error) {
	rsp, err := c.GetDevTokens(ctx, chain, devAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDevTokensResponse(rsp)
}

// ListTokenWithResponse request returning *ListTokenResponse
func (c *ClientWithResponses) ListTokenWithResponse(ctx context.Context, chain ChainSymbol, params *ListTokenParams, reqEditors ...RequestEditorFn) (*ListTokenResponse, error) {
	rsp, err := c.ListToken(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokenResponse(rsp)
}

// GetMarketDataMultiWithResponse request returning *GetMarketDataMultiResponse
func (c *ClientWithResponses) GetMarketDataMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetMarketDataMultiParams, reqEditors ...RequestEditorFn) (*GetMarketDataMultiResponse, error) {
	rsp, err := c.GetMarketDataMulti(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketDataMultiResponse(rsp)
}

// GetMetadataMultiWithResponse request returning *GetMetadataMultiResponse
func (c *ClientWithResponses) GetMetadataMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetMetadataMultiParams, reqEditors ...RequestEditorFn) (*GetMetadataMultiResponse, error) {
	rsp, err := c.GetMetadataMulti(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataMultiResponse(rsp)
}

// GetTokensWithResponse request returning *GetTokensResponse
func (c *ClientWithResponses) GetTokensWithResponse(ctx context.Context, chain ChainSymbol, params *GetTokensParams, reqEditors ...RequestEditorFn) (*GetTokensResponse, error) {
	rsp, err := c.GetTokens(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensResponse(rsp)
}

// GetStatsMultiWithResponse request returning *GetStatsMultiResponse
func (c *ClientWithResponses) GetStatsMultiWithResponse(ctx context.Context, chain ChainSymbol, params *GetStatsMultiParams, reqEditors ...RequestEditorFn) (*GetStatsMultiResponse, error) {
	rsp, err := c.GetStatsMulti(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsMultiResponse(rsp)
}

// GetTokenWithResponse request returning *GetTokenResponse
func (c *ClientWithResponses) GetTokenWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetTokenResponse, error) {
	rsp, err := c.GetToken(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenResponse(rsp)
}

// GetCandlesWithResponse request returning *GetCandlesResponse
func (c *ClientWithResponses) GetCandlesWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetCandlesParams, reqEditors ...RequestEditorFn) (*GetCandlesResponse, error) {
	rsp, err := c.GetCandles(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCandlesResponse(rsp)
}

// GetCreationWithResponse request returning *GetCreationResponse
func (c *ClientWithResponses) GetCreationWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetCreationResponse, error) {
	rsp, err := c.GetCreation(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCreationResponse(rsp)
}

// GetHoldersWithResponse request returning *GetHoldersResponse
func (c *ClientWithResponses) GetHoldersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersParams, reqEditors ...RequestEditorFn) (*GetHoldersResponse, error) {
	rsp, err := c.GetHolders(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHoldersResponse(rsp)
}

// GetHoldersMultiWithResponse request returning *GetHoldersMultiResponse
func (c *ClientWithResponses) GetHoldersMultiWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetHoldersMultiParams, reqEditors ...RequestEditorFn) (*GetHoldersMultiResponse, error) {
	rsp, err := c.GetHoldersMulti(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHoldersMultiResponse(rsp)
}

// GetTokenLiquiditySnapshotsWithResponse request returning *GetTokenLiquiditySnapshotsResponse
func (c *ClientWithResponses) GetTokenLiquiditySnapshotsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetTokenLiquiditySnapshotsParams, reqEditors ...RequestEditorFn) (*GetTokenLiquiditySnapshotsResponse, error) {
	rsp, err := c.GetTokenLiquiditySnapshots(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenLiquiditySnapshotsResponse(rsp)
}

// GetMarketDataWithResponse request returning *GetMarketDataResponse
func (c *ClientWithResponses) GetMarketDataWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetMarketDataResponse, error) {
	rsp, err := c.GetMarketData(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketDataResponse(rsp)
}

// GetMetadataWithResponse request returning *GetMetadataResponse
func (c *ClientWithResponses) GetMetadataWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetMetadataResponse, error) {
	rsp, err := c.GetMetadata(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataResponse(rsp)
}

// GetMintAndBurnWithResponse request returning *GetMintAndBurnResponse
func (c *ClientWithResponses) GetMintAndBurnWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetMintAndBurnParams, reqEditors ...RequestEditorFn) (*GetMintAndBurnResponse, error) {
	rsp, err := c.GetMintAndBurn(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMintAndBurnResponse(rsp)
}

// GetPoolsWithResponse request returning *GetPoolsResponse
func (c *ClientWithResponses) GetPoolsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPoolsParams, reqEditors ...RequestEditorFn) (*GetPoolsResponse, error) {
	rsp, err := c.GetPools(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoolsResponse(rsp)
}

// GetPriceByTimeWithResponse request returning *GetPriceByTimeResponse
func (c *ClientWithResponses) GetPriceByTimeWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPriceByTimeParams, reqEditors ...RequestEditorFn) (*GetPriceByTimeResponse, error) {
	rsp, err := c.GetPriceByTime(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceByTimeResponse(rsp)
}

// GetPricesWithResponse request returning *GetPricesResponse
func (c *ClientWithResponses) GetPricesWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, params *GetPricesParams, reqEditors ...RequestEditorFn) (*GetPricesResponse, error) {
	rsp, err := c.GetPrices(ctx, chain, tokenAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricesResponse(rsp)
}

// GetSecurityWithResponse request returning *GetSecurityResponse
func (c *ClientWithResponses) GetSecurityWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetSecurityResponse, error) {
	rsp, err := c.GetSecurity(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetTopHoldersWithResponse request returning *GetTopHoldersResponse
func (c *ClientWithResponses) GetTopHoldersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, reqEditors ...RequestEditorFn) (*GetTopHoldersResponse, error) {
	rsp, err := c.GetTopHolders(ctx, chain, tokenAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopHoldersResponse(rsp)
}

// GetTokenTradersWithResponse request returning *GetTokenTradersResponse
func (c *ClientWithResponses) GetTokenTradersWithResponse(ctx context.Context, chain ChainSymbol, tokenAddress string, tag TokenTraderTag, reqEditors ...RequestEditorFn) (*GetTokenTradersResponse, error) {
	rsp, err := c.GetTokenTraders(ctx, chain, tokenAddress, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenTradersResponse(rsp)
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDevTokensResponse parses an HTTP response from a GetDevTokensWithResponse call
func ParseGetDevTokensResponse(rsp *http.Response) (*GetDevTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDevTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DevTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTokenResponse parses an HTTP response from a ListTokenWithResponse call
func ParseListTokenResponse(rsp *http.Response) (*ListTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenListPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMarketDataMultiResponse parses an HTTP response from a GetMarketDataMultiWithResponse call
func ParseGetMarketDataMultiResponse(rsp *http.Response) (*GetMarketDataMultiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketDataMultiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]TokenMarketData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMetadataMultiResponse parses an HTTP response from a GetMetadataMultiWithResponse call
func ParseGetMetadataMultiResponse(rsp *http.Response) (*GetMetadataMultiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataMultiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]TokenMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokensResponse parses an HTTP response from a GetTokensWithResponse call
func ParseGetTokensResponse(rsp *http.Response) (*GetTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatsMultiResponse parses an HTTP response from a GetStatsMultiWithResponse call
func ParseGetStatsMultiResponse(rsp *http.Response) (*GetStatsMultiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsMultiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]TokenStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokenResponse parses an HTTP response from a GetTokenWithResponse call
func ParseGetTokenResponse(rsp *http.Response) (*GetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCandlesResponse parses an HTTP response from a GetCandlesWithResponse call
func ParseGetCandlesResponse(rsp *http.Response) (*GetCandlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCandlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Candle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCreationResponse parses an HTTP response from a GetCreationWithResponse call
func ParseGetCreationResponse(rsp *http.Response) (*GetCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenCreationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHoldersResponse parses an HTTP response from a GetHoldersWithResponse call
func ParseGetHoldersResponse(rsp *http.Response) (*GetHoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenHolderPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHoldersMultiResponse parses an HTTP response from a GetHoldersMultiWithResponse call
func ParseGetHoldersMultiResponse(rsp *http.Response) (*GetHoldersMultiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHoldersMultiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TokenHolder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokenLiquiditySnapshotsResponse parses an HTTP response from a GetTokenLiquiditySnapshotsWithResponse call
func ParseGetTokenLiquiditySnapshotsResponse(rsp *http.Response) (*GetTokenLiquiditySnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenLiquiditySnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenLiquiditySnapshotPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMarketDataResponse parses an HTTP response from a GetMarketDataWithResponse call
func ParseGetMarketDataResponse(rsp *http.Response) (*GetMarketDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenMarketData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMetadataResponse parses an HTTP response from a GetMetadataWithResponse call
func ParseGetMetadataResponse(rsp *http.Response) (*GetMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMintAndBurnResponse parses an HTTP response from a GetMintAndBurnWithResponse call
func ParseGetMintAndBurnResponse(rsp *http.Response) (*GetMintAndBurnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMintAndBurnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenCreationPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPoolsResponse parses an HTTP response from a GetPoolsWithResponse call
func ParseGetPoolsResponse(rsp *http.Response) (*GetPoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DexPoolPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPriceByTimeResponse parses an HTTP response from a GetPriceByTimeWithResponse call
func ParseGetPriceByTimeResponse(rsp *http.Response) (*GetPriceByTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceByTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPriceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPricesResponse parses an HTTP response from a GetPricesWithResponse call
func ParseGetPricesResponse(rsp *http.Response) (*GetPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPricePage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSecurityResponse parses an HTTP response from a GetSecurityWithResponse call
func ParseGetSecurityResponse(rsp *http.Response) (*GetSecurityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopHoldersResponse parses an HTTP response from a GetTopHoldersWithResponse call
func ParseGetTopHoldersResponse(rsp *http.Response) (*GetTopHoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopHoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenHolderPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokenTradersResponse parses an HTTP response from a GetTokenTradersWithResponse call
func ParseGetTokenTradersResponse(rsp *http.Response) (*GetTokenTradersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokenTradersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TokenTrader
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
