// Package wallet provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package wallet

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for BalanceChangeType.
const (
	DECREASE BalanceChangeType = "DECREASE"
	INCREASE BalanceChangeType = "INCREASE"
)

// Defines values for BalanceTokenType.
const (
	SOL BalanceTokenType = "SOL"
	SPL BalanceTokenType = "SPL"
)

// Defines values for ChainSymbol.
const (
	Bsc ChainSymbol = "bsc"
	Eth ChainSymbol = "eth"
	Sol ChainSymbol = "sol"
)

// BalanceChangeType defines model for BalanceChangeType.
type BalanceChangeType string

// BalanceTokenType defines model for BalanceTokenType.
type BalanceTokenType string

// BalanceUpdateDTO defines model for BalanceUpdateDTO.
type BalanceUpdateDTO struct {
	// AccountOwnerAddress DTO.WALLET.BALANCE_UPDATE.ACCOUNT_OWNER_ADDRESS
	AccountOwnerAddress string `json:"accountOwnerAddress"`

	// BalanceChange DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE
	BalanceChange string `json:"balanceChange"`

	// BalanceChangeInNative DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE_IN_NATIVE
	BalanceChangeInNative string `json:"balanceChangeInNative"`

	// BalanceChangeInUsd DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE_IN_USD
	BalanceChangeInUsd string `json:"balanceChangeInUsd"`

	// BlockHash DTO.WALLET.BALANCE_UPDATE.BLOCK_HASH
	BlockHash string `json:"blockHash"`

	// BlockHeight DTO.WALLET.BALANCE_UPDATE.BLOCK_HEIGHT
	BlockHeight int64 `json:"blockHeight"`

	// BlockSlot DTO.WALLET.BALANCE_UPDATE.BLOCK_SLOT
	BlockSlot int64 `json:"blockSlot"`

	// BlockTimestamp DTO.WALLET.BALANCE_UPDATE.BLOCK_TIMESTAMP
	BlockTimestamp int64 `json:"blockTimestamp"`

	// ChangeType DTO.WALLET.BALANCE_UPDATE.CHANGE_TYPE
	ChangeType BalanceChangeType `json:"changeType"`

	// Id DTO.WALLET.BALANCE_UPDATE.ID
	Id int64 `json:"id"`

	// Index DTO.WALLET.BALANCE_UPDATE.INDEX
	Index int64 `json:"index"`

	// PostBalance DTO.WALLET.BALANCE_UPDATE.POST_BALANCE
	PostBalance string `json:"postBalance"`

	// PostBalanceInNative DTO.WALLET.BALANCE_UPDATE.POST_BALANCE_IN_NATIVE
	PostBalanceInNative string `json:"postBalanceInNative"`

	// PostBalanceInUsd DTO.WALLET.BALANCE_UPDATE.POST_BALANCE_IN_USD
	PostBalanceInUsd string `json:"postBalanceInUsd"`

	// PreBalance DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE
	PreBalance string `json:"preBalance"`

	// PreBalanceInNative DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE_IN_NATIVE
	PreBalanceInNative string `json:"preBalanceInNative"`

	// PreBalanceInUsd DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE_IN_USD
	PreBalanceInUsd string `json:"preBalanceInUsd"`

	// TokenAccountAddress DTO.WALLET.BALANCE_UPDATE.TOKEN_ACCOUNT_ADDRESS
	TokenAccountAddress string `json:"tokenAccountAddress"`

	// TokenAddress DTO.WALLET.BALANCE_UPDATE.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TransactionSignature DTO.WALLET.BALANCE_UPDATE.TRANSACTION_SIGNATURE
	TransactionSignature string `json:"transactionSignature"`

	// Type DTO.WALLET.BALANCE_UPDATE.TYPE
	Type BalanceTokenType `json:"type"`
}

// BalanceUpdatePage defines model for BalanceUpdatePage.
type BalanceUpdatePage struct {
	// Data DTO.PAGE.DATA
	Data []BalanceUpdateDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext bool `json:"hasNext"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev bool `json:"hasPrev"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`
}

// BooleanResultDTO defines model for BooleanResultDTO.
type BooleanResultDTO struct {
	// Success DTO.BOOLEAN_RESULT.SUCCESS
	Success bool `json:"success"`
}

// CalculatePnlInput defines model for CalculatePnlInput.
type CalculatePnlInput struct {
	// TokenAddresses DTO.WALLET.CALCULATE_PNL.INPUT.TOKEN_ADDRESSES
	TokenAddresses *[]string `json:"tokenAddresses,omitempty"`
}

// ChainSymbol defines model for ChainSymbol.
type ChainSymbol string

// WalletBalanceDetailDTO defines model for WalletBalanceDetailDTO.
type WalletBalanceDetailDTO struct {
	// Amount DTO.WALLET.BALANCE.AMOUNT
	Amount string `json:"amount"`

	// AverageBuyPriceInUsd DTO.WALLET.BALANCE.AVERAGE_BUY_PRICE
	AverageBuyPriceInUsd string `json:"averageBuyPriceInUsd"`

	// AverageSellPriceInUsd DTO.WALLET.BALANCE.AVERAGE_SELL_PRICE
	AverageSellPriceInUsd string `json:"averageSellPriceInUsd"`

	// BuyAmount DTO.WALLET.BALANCE.BUY_AMOUNT
	BuyAmount string `json:"buyAmount"`

	// BuyAmountInUsd DTO.WALLET.BALANCE.BUY_AMOUNT_USD
	BuyAmountInUsd string `json:"buyAmountInUsd"`

	// Buys DTO.WALLET.BALANCE.BUYS
	Buys string `json:"buys"`

	// CloseTime DTO.WALLET.BALANCE.CLOSE_TIME
	CloseTime int64 `json:"closeTime"`

	// ImageUrl DTO.WALLET.BALANCE.TOKEN_IMAGE_URL
	ImageUrl string `json:"imageUrl"`

	// Name DTO.WALLET.BALANCE.TOKEN_NAME
	Name string `json:"name"`

	// OpenTime DTO.WALLET.BALANCE.OPEN_TIME
	OpenTime int64 `json:"openTime"`

	// PriceChangeRatioInUsd24h DTO.WALLET.BALANCE.PRICE_CHANGE_24H
	PriceChangeRatioInUsd24h string `json:"priceChangeRatioInUsd24h"`

	// PriceInSol DTO.WALLET.BALANCE.TOKEN_PRICE_IN_SOL
	PriceInSol string `json:"priceInSol"`

	// PriceInUsd DTO.WALLET.BALANCE.TOKEN_PRICE_IN_USD
	PriceInUsd string `json:"priceInUsd"`

	// RealizedProfitInUsd DTO.WALLET.BALANCE.REALIZED_PROFIT_IN_USD
	RealizedProfitInUsd string `json:"realizedProfitInUsd"`

	// RealizedProfitRatio DTO.WALLET.BALANCE.REALIZED_PROFIT_RATIO
	RealizedProfitRatio string `json:"realizedProfitRatio"`

	// SellAmount DTO.WALLET.BALANCE.SELL_AMOUNT
	SellAmount string `json:"sellAmount"`

	// SellAmountInUsd DTO.WALLET.BALANCE.SELL_AMOUNT_USD
	SellAmountInUsd string `json:"sellAmountInUsd"`

	// Sells DTO.WALLET.BALANCE.SELLS
	Sells string `json:"sells"`

	// Symbol DTO.WALLET.BALANCE.TOKEN_SYMBOL
	Symbol string `json:"symbol"`

	// TokenAddress DTO.WALLET.BALANCE.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TotalRealizedProfitInUsd DTO.WALLET.BALANCE.TOTAL_REALIZED_PROFIT
	TotalRealizedProfitInUsd string `json:"totalRealizedProfitInUsd"`

	// TotalRealizedProfitRatio DTO.WALLET.BALANCE.TOTAL_REALIZED_PROFIT_RATIO
	TotalRealizedProfitRatio string `json:"totalRealizedProfitRatio"`

	// UnrealizedProfitInUsd DTO.WALLET.BALANCE.UNREALIZED_PROFIT
	UnrealizedProfitInUsd string `json:"unrealizedProfitInUsd"`

	// UnrealizedProfitRatio DTO.WALLET.BALANCE.UNREALIZED_PROFIT_RATIO
	UnrealizedProfitRatio string `json:"unrealizedProfitRatio"`

	// ValueInUsd DTO.WALLET.BALANCE.AMOUNT_IN_USD
	ValueInUsd string `json:"valueInUsd"`
}

// WalletBalancesDTO defines model for WalletBalancesDTO.
type WalletBalancesDTO struct {
	// Balances DTO.WALLET.BALANCES.BALANCES.DETAIL
	Balances []WalletBalanceDetailDTO `json:"balances"`

	// TotalBalancesInUsd DTO.WALLET.BALANCES.TOTAL_BALANCES_IN_USD
	TotalBalancesInUsd string `json:"totalBalancesInUsd"`

	// TotalProfitInUsd DTO.WALLET.BALANCES.TOTAL_PROFIT_IN_USD
	TotalProfitInUsd string `json:"totalProfitInUsd"`
}

// WalletPnlDTO defines model for WalletPnlDTO.
type WalletPnlDTO struct {
	// AverageBuyPriceInUsd DTO.WALLET.PNL.AVERAGE_BUY_PRICE
	AverageBuyPriceInUsd string `json:"averageBuyPriceInUsd"`

	// AverageSellPriceInUsd DTO.WALLET.PNL.AVERAGE_SELL_PRICE
	AverageSellPriceInUsd string `json:"averageSellPriceInUsd"`

	// Balance DTO.WALLET.PNL.BALANCE
	Balance string `json:"balance"`

	// BuyAmount DTO.WALLET.PNL.BUY_AMOUNT
	BuyAmount string `json:"buyAmount"`

	// BuyAmountInUsd DTO.WALLET.PNL.BUY_AMOUNT_USD
	BuyAmountInUsd string `json:"buyAmountInUsd"`

	// Buys DTO.WALLET.PNL.BUYS
	Buys string `json:"buys"`

	// Chain DTO.WALLET.PNL.CHAIN
	Chain string `json:"chain"`

	// CloseTime DTO.WALLET.PNL.CLOSE_TIME
	CloseTime int64 `json:"closeTime"`

	// Id DTO.WALLET.PNL.ID
	Id int64 `json:"id"`

	// LastTime DTO.WALLET.PNL.LAST_TIME
	LastTime int64 `json:"lastTime"`

	// OpenTime DTO.WALLET.PNL.OPEN_TIME
	OpenTime int64 `json:"openTime"`

	// RealizedProfitInUsd DTO.WALLET.PNL.REALIZED_PROFIT
	RealizedProfitInUsd string `json:"realizedProfitInUsd"`

	// RealizedProfitRatio DTO.WALLET.PNL.REALIZED_PROFIT_RATIO
	RealizedProfitRatio string `json:"realizedProfitRatio"`

	// SellAmount DTO.WALLET.PNL.SELL_AMOUNT
	SellAmount string `json:"sellAmount"`

	// SellAmountInUsd DTO.WALLET.PNL.SELL_AMOUNT_USD
	SellAmountInUsd string `json:"sellAmountInUsd"`

	// Sells DTO.WALLET.PNL.SELLS
	Sells string `json:"sells"`

	// TokenAddress DTO.WALLET.PNL.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TokenPriceInUsd DTO.WALLET.PNL.TOKEN_PRICE
	TokenPriceInUsd string `json:"tokenPriceInUsd"`

	// TotalRealizedProfitInUsd DTO.WALLET.PNL.TOTAL_REALIZED_PROFIT
	TotalRealizedProfitInUsd string `json:"totalRealizedProfitInUsd"`

	// TotalRealizedProfitRatio DTO.WALLET.PNL.TOTAL_REALIZED_PROFIT_RATIO
	TotalRealizedProfitRatio string `json:"totalRealizedProfitRatio"`

	// UnrealizedProfitInUsd DTO.WALLET.PNL.UNREALIZED_PROFIT
	UnrealizedProfitInUsd string `json:"unrealizedProfitInUsd"`

	// UnrealizedProfitRatio DTO.WALLET.PNL.UNREALIZED_PROFIT_RATIO
	UnrealizedProfitRatio string `json:"unrealizedProfitRatio"`

	// WalletAddress DTO.WALLET.PNL.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// GetPnlParams defines parameters for GetPnl.
type GetPnlParams struct {
	// TokenAddress GLOBAL.TOKENADDRESS.DESCRIPTION
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`
}

// GetBalanceParams defines parameters for GetBalance.
type GetBalanceParams struct {
	// TokenAddress DTO.WALLET.BALANCE.QUERY.TOKEN_ADDRESS
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`
}

// GetBalanceUpdatesParams defines parameters for GetBalanceUpdates.
type GetBalanceUpdatesParams struct {
	// TokenAddress DTO.WALLET.BALANCE_UPDATE.QUERY.TOKEN_ADDRESS
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`

	// TimeFrom DTO.WALLET.BALANCE_UPDATE.QUERY.TIME_FROM
	TimeFrom *int64 `form:"timeFrom,omitempty" json:"timeFrom,omitempty"`

	// TimeTo DTO.WALLET.BALANCE_UPDATE.QUERY.TIME_TO
	TimeTo *int64 `form:"timeTo,omitempty" json:"timeTo,omitempty"`

	// Type DTO.WALLET.BALANCE_UPDATE.QUERY.TYPE
	Type *BalanceTokenType `form:"type,omitempty" json:"type,omitempty"`

	// ChangeType DTO.WALLET.BALANCE_UPDATE.QUERY.CHANGE_TYPE
	ChangeType *BalanceChangeType `form:"changeType,omitempty" json:"changeType,omitempty"`

	// Cursor DTO.PAGE.CURSOR
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CalculatePnlJSONRequestBody defines body for CalculatePnl for application/json ContentType.
type CalculatePnlJSONRequestBody = CalculatePnlInput

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPnl request
	GetPnl(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalance request
	GetBalance(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalanceUpdates request
	GetBalanceUpdates(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculatePnlWithBody request with any body
	CalculatePnlWithBody(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculatePnl(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPnlStats request
	GetPnlStats(ctx context.Context, chain ChainSymbol, walletAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPnl(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalance(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalanceUpdates(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceUpdatesRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculatePnlWithBody(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculatePnlRequestWithBody(c.Server, chain, walletAddress, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculatePnl(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculatePnlRequest(c.Server, chain, walletAddress, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPnlStats(ctx context.Context, chain ChainSymbol, walletAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlStatsRequest(c.Server, chain, walletAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPnlRequest generates requests for GetPnl
func NewGetPnlRequest(server string, chain ChainSymbol, walletAddress string, params *GetPnlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBalanceRequest generates requests for GetBalance
func NewGetBalanceRequest(server string, chain ChainSymbol, walletAddress string, params *GetBalanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/balance", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBalanceUpdatesRequest generates requests for GetBalanceUpdates
func NewGetBalanceUpdatesRequest(server string, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/balance-updates", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeFrom", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeTo", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChangeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changeType", runtime.ParamLocationQuery, *params.ChangeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCalculatePnlRequest calls the generic CalculatePnl builder with application/json body
func NewCalculatePnlRequest(server string, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculatePnlRequestWithBody(server, chain, walletAddress, "application/json", bodyReader)
}

// NewCalculatePnlRequestWithBody generates requests for CalculatePnl with any type of body
func NewCalculatePnlRequestWithBody(server string, chain ChainSymbol, walletAddress string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/calculate-pnl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPnlStatsRequest generates requests for GetPnlStats
func NewGetPnlStatsRequest(server string, chain ChainSymbol, walletAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/stats", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPnlWithResponse request
	GetPnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*GetPnlResponse, error)

	// GetBalanceWithResponse request
	GetBalanceWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error)

	// GetBalanceUpdatesWithResponse request
	GetBalanceUpdatesWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBalanceUpdatesResponse, error)

	// CalculatePnlWithBodyWithResponse request with any body
	CalculatePnlWithBodyWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error)

	CalculatePnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error)

	// GetPnlStatsWithResponse request
	GetPnlStatsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, reqEditors ...RequestEditorFn) (*GetPnlStatsResponse, error)
}

type GetPnlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WalletPnlDTO
}

// Status returns HTTPResponse.Status
func (r GetPnlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletBalancesDTO
}

// Status returns HTTPResponse.Status
func (r GetBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceUpdatePage
}

// Status returns HTTPResponse.Status
func (r GetBalanceUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculatePnlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BooleanResultDTO
}

// Status returns HTTPResponse.Status
func (r CalculatePnlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculatePnlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPnlStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WalletPnlDTO
}

// Status returns HTTPResponse.Status
func (r GetPnlStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPnlWithResponse request returning *GetPnlResponse
func (c *ClientWithResponses) GetPnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*GetPnlResponse, error) {
	rsp, err := c.GetPnl(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlResponse(rsp)
}

// GetBalanceWithResponse request returning *GetBalanceResponse
func (c *ClientWithResponses) GetBalanceWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error) {
	rsp, err := c.GetBalance(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceResponse(rsp)
}

// GetBalanceUpdatesWithResponse request returning *GetBalanceUpdatesResponse
func (c *ClientWithResponses) GetBalanceUpdatesWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBalanceUpdatesResponse, error) {
	rsp, err := c.GetBalanceUpdates(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceUpdatesResponse(rsp)
}

// CalculatePnlWithBodyWithResponse request with arbitrary body returning *CalculatePnlResponse
func (c *ClientWithResponses) CalculatePnlWithBodyWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error) {
	rsp, err := c.CalculatePnlWithBody(ctx, chain, walletAddress, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculatePnlResponse(rsp)
}

func (c *ClientWithResponses) CalculatePnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error) {
	rsp, err := c.CalculatePnl(ctx, chain, walletAddress, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculatePnlResponse(rsp)
}

// GetPnlStatsWithResponse request returning *GetPnlStatsResponse
func (c *ClientWithResponses) GetPnlStatsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, reqEditors ...RequestEditorFn) (*GetPnlStatsResponse, error) {
	rsp, err := c.GetPnlStats(ctx, chain, walletAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlStatsResponse(rsp)
}

// ParseGetPnlResponse parses an HTTP response from a GetPnlWithResponse call
func ParseGetPnlResponse(rsp *http.Response) (*GetPnlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WalletPnlDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBalanceResponse parses an HTTP response from a GetBalanceWithResponse call
func ParseGetBalanceResponse(rsp *http.Response) (*GetBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletBalancesDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBalanceUpdatesResponse parses an HTTP response from a GetBalanceUpdatesWithResponse call
func ParseGetBalanceUpdatesResponse(rsp *http.Response) (*GetBalanceUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceUpdatePage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCalculatePnlResponse parses an HTTP response from a CalculatePnlWithResponse call
func ParseCalculatePnlResponse(rsp *http.Response) (*CalculatePnlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculatePnlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BooleanResultDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPnlStatsResponse parses an HTTP response from a GetPnlStatsWithResponse call
func ParseGetPnlStatsResponse(rsp *http.Response) (*GetPnlStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WalletPnlDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
