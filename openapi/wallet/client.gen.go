// Package wallet provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package wallet

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for BalanceChangeType.
const (
	DECREASE BalanceChangeType = "DECREASE"
	INCREASE BalanceChangeType = "INCREASE"
)

// Defines values for BalanceTokenType.
const (
	SOL BalanceTokenType = "SOL"
	SPL BalanceTokenType = "SPL"
)

// Defines values for ChainSymbol.
const (
	Bsc ChainSymbol = "bsc"
	Eth ChainSymbol = "eth"
	Sol ChainSymbol = "sol"
)

// Defines values for PnlResolution.
const (
	PnlResolutionAll  PnlResolution = "all"
	PnlResolutionN1d  PnlResolution = "1d"
	PnlResolutionN30d PnlResolution = "30d"
	PnlResolutionN7d  PnlResolution = "7d"
)

// Defines values for TransactionHistoryItemDTOMainAction.
const (
	Receive TransactionHistoryItemDTOMainAction = "receive"
	Send    TransactionHistoryItemDTOMainAction = "send"
)

// Defines values for TransactionHistoryItemDTOStatus.
const (
	FAILED    TransactionHistoryItemDTOStatus = "FAILED"
	SUCCEEDED TransactionHistoryItemDTOStatus = "SUCCEEDED"
	UNKNOWN   TransactionHistoryItemDTOStatus = "UNKNOWN"
)

// Defines values for WalletPnlSummaryDTOResolution.
const (
	WalletPnlSummaryDTOResolutionAll  WalletPnlSummaryDTOResolution = "all"
	WalletPnlSummaryDTOResolutionN1d  WalletPnlSummaryDTOResolution = "1d"
	WalletPnlSummaryDTOResolutionN30d WalletPnlSummaryDTOResolution = "30d"
	WalletPnlSummaryDTOResolutionN7d  WalletPnlSummaryDTOResolution = "7d"
)

// Defines values for GetPnlByWalletParamsDirection.
const (
	GetPnlByWalletParamsDirectionNext GetPnlByWalletParamsDirection = "next"
	GetPnlByWalletParamsDirectionPrev GetPnlByWalletParamsDirection = "prev"
)

// Defines values for GetBalanceUpdatesParamsDirection.
const (
	GetBalanceUpdatesParamsDirectionNext GetBalanceUpdatesParamsDirection = "next"
	GetBalanceUpdatesParamsDirectionPrev GetBalanceUpdatesParamsDirection = "prev"
)

// Defines values for GetNetWorthParamsDirection.
const (
	GetNetWorthParamsDirectionNext GetNetWorthParamsDirection = "next"
	GetNetWorthParamsDirectionPrev GetNetWorthParamsDirection = "prev"
)

// Defines values for GetNetWorthDetailsParamsDirection.
const (
	GetNetWorthDetailsParamsDirectionNext GetNetWorthDetailsParamsDirection = "next"
	GetNetWorthDetailsParamsDirectionPrev GetNetWorthDetailsParamsDirection = "prev"
)

// Defines values for GetPnlByTokenParamsDirection.
const (
	GetPnlByTokenParamsDirectionNext GetPnlByTokenParamsDirection = "next"
	GetPnlByTokenParamsDirectionPrev GetPnlByTokenParamsDirection = "prev"
)

// Defines values for GetPnlDetailsParamsDirection.
const (
	GetPnlDetailsParamsDirectionNext GetPnlDetailsParamsDirection = "next"
	GetPnlDetailsParamsDirectionPrev GetPnlDetailsParamsDirection = "prev"
)

// Defines values for GetTokensBalanceParamsDirection.
const (
	GetTokensBalanceParamsDirectionNext GetTokensBalanceParamsDirection = "next"
	GetTokensBalanceParamsDirectionPrev GetTokensBalanceParamsDirection = "prev"
)

// Defines values for GetWalletTransferTotalParamsDirection.
const (
	GetWalletTransferTotalParamsDirectionNext GetWalletTransferTotalParamsDirection = "next"
	GetWalletTransferTotalParamsDirectionPrev GetWalletTransferTotalParamsDirection = "prev"
)

// Defines values for GetWalletTransfersParamsDirection.
const (
	Next GetWalletTransfersParamsDirection = "next"
	Prev GetWalletTransfersParamsDirection = "prev"
)

// BalanceChangeType defines model for BalanceChangeType.
type BalanceChangeType string

// BalanceTokenType defines model for BalanceTokenType.
type BalanceTokenType string

// BalanceUpdateDTO defines model for BalanceUpdateDTO.
type BalanceUpdateDTO struct {
	// AccountOwnerAddress DTO.WALLET.BALANCE_UPDATE.ACCOUNT_OWNER_ADDRESS
	AccountOwnerAddress string `json:"accountOwnerAddress"`

	// BalanceChange DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE
	BalanceChange string `json:"balanceChange"`

	// BalanceChangeInNative DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE_IN_NATIVE
	BalanceChangeInNative string `json:"balanceChangeInNative"`

	// BalanceChangeInUsd DTO.WALLET.BALANCE_UPDATE.BALANCE_CHANGE_IN_USD
	BalanceChangeInUsd string `json:"balanceChangeInUsd"`

	// BlockHash DTO.WALLET.BALANCE_UPDATE.BLOCK_HASH
	BlockHash string `json:"blockHash"`

	// BlockHeight DTO.WALLET.BALANCE_UPDATE.BLOCK_HEIGHT
	BlockHeight int64 `json:"blockHeight"`

	// BlockSlot DTO.WALLET.BALANCE_UPDATE.BLOCK_SLOT
	BlockSlot int64 `json:"blockSlot"`

	// BlockTimestamp DTO.WALLET.BALANCE_UPDATE.BLOCK_TIMESTAMP
	BlockTimestamp int64 `json:"blockTimestamp"`

	// ChangeType DTO.WALLET.BALANCE_UPDATE.CHANGE_TYPE
	ChangeType BalanceChangeType `json:"changeType"`

	// Id DTO.WALLET.BALANCE_UPDATE.ID
	Id int64 `json:"id"`

	// Index DTO.WALLET.BALANCE_UPDATE.INDEX
	Index int64 `json:"index"`

	// PostBalance DTO.WALLET.BALANCE_UPDATE.POST_BALANCE
	PostBalance string `json:"postBalance"`

	// PostBalanceInNative DTO.WALLET.BALANCE_UPDATE.POST_BALANCE_IN_NATIVE
	PostBalanceInNative string `json:"postBalanceInNative"`

	// PostBalanceInUsd DTO.WALLET.BALANCE_UPDATE.POST_BALANCE_IN_USD
	PostBalanceInUsd string `json:"postBalanceInUsd"`

	// PreBalance DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE
	PreBalance string `json:"preBalance"`

	// PreBalanceInNative DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE_IN_NATIVE
	PreBalanceInNative string `json:"preBalanceInNative"`

	// PreBalanceInUsd DTO.WALLET.BALANCE_UPDATE.PRE_BALANCE_IN_USD
	PreBalanceInUsd string `json:"preBalanceInUsd"`

	// TokenAccountAddress DTO.WALLET.BALANCE_UPDATE.TOKEN_ACCOUNT_ADDRESS
	TokenAccountAddress string `json:"tokenAccountAddress"`

	// TokenAddress DTO.WALLET.BALANCE_UPDATE.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TransactionSignature DTO.WALLET.BALANCE_UPDATE.TRANSACTION_SIGNATURE
	TransactionSignature string `json:"transactionSignature"`

	// Type DTO.WALLET.BALANCE_UPDATE.TYPE
	Type BalanceTokenType `json:"type"`
}

// BalanceUpdatePage defines model for BalanceUpdatePage.
type BalanceUpdatePage struct {
	// Data DTO.PAGE.DATA
	Data []BalanceUpdateDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext bool `json:"hasNext"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev bool `json:"hasPrev"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`
}

// BooleanResultDTO defines model for BooleanResultDTO.
type BooleanResultDTO struct {
	// Success DTO.BOOLEAN_RESULT.SUCCESS
	Success bool `json:"success"`
}

// CalculatePnlInput defines model for CalculatePnlInput.
type CalculatePnlInput struct {
	// TokenAddresses DTO.WALLET.CALCULATE_PNL.INPUT.TOKEN_ADDRESSES
	TokenAddresses *[]string `json:"tokenAddresses,omitempty"`
}

// ChainSymbol defines model for ChainSymbol.
type ChainSymbol string

// PnlDetailItemDTO defines model for PnlDetailItemDTO.
type PnlDetailItemDTO struct {
	// AvgBuyPriceInUsd DTO.WALLET.PNL_DETAIL.ITEM.AVG_BUY_PRICE_IN_USD
	AvgBuyPriceInUsd string `json:"avgBuyPriceInUsd"`

	// AvgProfitPerTradeInUsd DTO.WALLET.PNL_DETAIL.ITEM.AVG_PROFIT_PER_TRADE_IN_USD
	AvgProfitPerTradeInUsd string `json:"avgProfitPerTradeInUsd"`

	// AvgSellPriceInUsd DTO.WALLET.PNL_DETAIL.ITEM.AVG_SELL_PRICE_IN_USD
	AvgSellPriceInUsd string `json:"avgSellPriceInUsd"`

	// Balance DTO.WALLET.PNL_DETAIL.ITEM.BALANCE
	Balance string `json:"balance"`

	// BuyAmount DTO.WALLET.PNL_DETAIL.ITEM.BUY_AMOUNT
	BuyAmount string `json:"buyAmount"`

	// BuyAmountInUsd DTO.WALLET.PNL_DETAIL.ITEM.BUY_AMOUNT_IN_USD
	BuyAmountInUsd string `json:"buyAmountInUsd"`

	// Buys DTO.WALLET.PNL_DETAIL.ITEM.BUYS
	Buys string `json:"buys"`

	// CurrentValue DTO.WALLET.PNL_DETAIL.ITEM.CURRENT_VALUE
	CurrentValue string `json:"currentValue"`

	// Decimals DTO.WALLET.PNL_DETAIL.ITEM.DECIMALS
	Decimals int64 `json:"decimals"`

	// LogoUri DTO.WALLET.PNL_DETAIL.ITEM.LOGO_URI
	LogoUri *string `json:"logoUri,omitempty"`

	// Name DTO.WALLET.PNL_DETAIL.ITEM.NAME
	Name string `json:"name"`

	// PriceInUsd DTO.WALLET.PNL_DETAIL.ITEM.PRICE_IN_USD
	PriceInUsd string `json:"priceInUsd"`

	// RealizedProfitInUsd DTO.WALLET.PNL_DETAIL.ITEM.REALIZED_PROFIT_IN_USD
	RealizedProfitInUsd string `json:"realizedProfitInUsd"`

	// RealizedProfitRatio DTO.WALLET.PNL_DETAIL.ITEM.REALIZED_PROFIT_RATIO
	RealizedProfitRatio string `json:"realizedProfitRatio"`

	// SellAmount DTO.WALLET.PNL_DETAIL.ITEM.SELL_AMOUNT
	SellAmount string `json:"sellAmount"`

	// SellAmountInUsd DTO.WALLET.PNL_DETAIL.ITEM.SELL_AMOUNT_IN_USD
	SellAmountInUsd string `json:"sellAmountInUsd"`

	// Sells DTO.WALLET.PNL_DETAIL.ITEM.SELLS
	Sells string `json:"sells"`

	// Symbol DTO.WALLET.PNL_DETAIL.ITEM.SYMBOL
	Symbol string `json:"symbol"`

	// TokenAddress DTO.WALLET.PNL_DETAIL.ITEM.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TotalProfitInUsd DTO.WALLET.PNL_DETAIL.ITEM.TOTAL_PROFIT_IN_USD
	TotalProfitInUsd string `json:"totalProfitInUsd"`

	// TotalProfitRatio DTO.WALLET.PNL_DETAIL.ITEM.TOTAL_PROFIT_RATIO
	TotalProfitRatio string `json:"totalProfitRatio"`

	// TotalTrades DTO.WALLET.PNL_DETAIL.ITEM.TOTAL_TRADES
	TotalTrades string `json:"totalTrades"`

	// UnrealizedProfitInUsd DTO.WALLET.PNL_DETAIL.ITEM.UNREALIZED_PROFIT_IN_USD
	UnrealizedProfitInUsd string `json:"unrealizedProfitInUsd"`

	// UnrealizedProfitRatio DTO.WALLET.PNL_DETAIL.ITEM.UNREALIZED_PROFIT_RATIO
	UnrealizedProfitRatio string `json:"unrealizedProfitRatio"`

	// WalletAddress DTO.WALLET.PNL_DETAIL.ITEM.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// PnlDetailSummaryDTO defines model for PnlDetailSummaryDTO.
type PnlDetailSummaryDTO struct {
	// AvgProfitPerTradeInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.AVG_PROFIT_PER_TRADE_IN_USD
	AvgProfitPerTradeInUsd string `json:"avgProfitPerTradeInUsd"`

	// BuyAmountInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.BUY_AMOUNT_IN_USD
	BuyAmountInUsd string `json:"buyAmountInUsd"`

	// Buys DTO.WALLET.PNL_DETAIL.SUMMARY.BUYS
	Buys string `json:"buys"`

	// CurrentValue DTO.WALLET.PNL_DETAIL.SUMMARY.CURRENT_VALUE
	CurrentValue string `json:"currentValue"`

	// Losses DTO.WALLET.PNL_DETAIL.SUMMARY.LOSSES
	Losses string `json:"losses"`

	// RealizedProfitInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.REALIZED_PROFIT_IN_USD
	RealizedProfitInUsd string `json:"realizedProfitInUsd"`

	// RealizedProfitRatio DTO.WALLET.PNL_DETAIL.SUMMARY.REALIZED_PROFIT_RATIO
	RealizedProfitRatio string `json:"realizedProfitRatio"`

	// SellAmountInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.SELL_AMOUNT_IN_USD
	SellAmountInUsd string `json:"sellAmountInUsd"`

	// Sells DTO.WALLET.PNL_DETAIL.SUMMARY.SELLS
	Sells string `json:"sells"`

	// Tokens DTO.WALLET.PNL_DETAIL.SUMMARY.TOKENS
	Tokens string `json:"tokens"`

	// TotalCostInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.TOTAL_COST_IN_USD
	TotalCostInUsd string `json:"totalCostInUsd"`

	// TotalProfitInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.TOTAL_PROFIT_IN_USD
	TotalProfitInUsd string `json:"totalProfitInUsd"`

	// TotalTrades DTO.WALLET.PNL_DETAIL.SUMMARY.TOTAL_TRADES
	TotalTrades string `json:"totalTrades"`

	// UnrealizedProfitInUsd DTO.WALLET.PNL_DETAIL.SUMMARY.UNREALIZED_PROFIT_IN_USD
	UnrealizedProfitInUsd string `json:"unrealizedProfitInUsd"`

	// WinRate DTO.WALLET.PNL_DETAIL.SUMMARY.WIN_RATE
	WinRate string `json:"winRate"`

	// Wins DTO.WALLET.PNL_DETAIL.SUMMARY.WINS
	Wins string `json:"wins"`
}

// PnlDetailsPage defines model for PnlDetailsPage.
type PnlDetailsPage struct {
	// Data DTO.PAGE.DATA
	Data []PnlDetailItemDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Summary DTO.WALLET.PNL_DETAIL.SUMMARY
	Summary PnlDetailSummaryDTO `json:"summary"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// PnlResolution defines model for PnlResolution.
type PnlResolution string

// TokenTransferTotalDTO defines model for TokenTransferTotalDTO.
type TokenTransferTotalDTO struct {
	// Total DTO.TOKEN.TRANSFER.TOTAL
	Total int64 `json:"total"`
}

// TokensBalancePage defines model for TokensBalancePage.
type TokensBalancePage struct {
	// Data DTO.PAGE.DATA
	Data []WalletNetWorthItemDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// TransactionHistoryItemDTO defines model for TransactionHistoryItemDTO.
type TransactionHistoryItemDTO struct {
	// BlockNumber DTO.WALLET.TX_HISTORY.BLOCK_NUMBER
	BlockNumber int64 `json:"blockNumber"`

	// BlockTime DTO.WALLET.TX_HISTORY.BLOCK_TIME
	BlockTime int64 `json:"blockTime"`

	// DappProgram DTO.WALLET.TX_HISTORY.DAPP_PROGRAM
	DappProgram string `json:"dappProgram"`

	// Decimals DTO.WALLET.TX_HISTORY.DECIMALS
	Decimals int64 `json:"decimals"`

	// Fee DTO.WALLET.TX_HISTORY.FEE
	Fee string `json:"fee"`

	// From DTO.WALLET.TX_HISTORY.FROM
	From string `json:"from"`

	// FromTokenAccount DTO.WALLET.TX_HISTORY.FROM_TOKEN_ACCOUNT
	FromTokenAccount string `json:"fromTokenAccount"`

	// FromUserAccount DTO.WALLET.TX_HISTORY.FROM_USER_ACCOUNT
	FromUserAccount string `json:"fromUserAccount"`

	// LogoUri DTO.WALLET.TX_HISTORY.LOGO_URI
	LogoUri *string `json:"logoUri,omitempty"`

	// MainAction DTO.WALLET.TX_HISTORY.MAIN_ACTION
	MainAction TransactionHistoryItemDTOMainAction `json:"mainAction"`

	// Name DTO.WALLET.TX_HISTORY.NAME
	Name string `json:"name"`

	// OuterDappProgram DTO.WALLET.TX_HISTORY.OUTER_DAPP_PROGRAM
	OuterDappProgram string `json:"outerDappProgram"`

	// Status DTO.WALLET.TX_HISTORY.STATUS
	Status TransactionHistoryItemDTOStatus `json:"status"`

	// Symbol DTO.WALLET.TX_HISTORY.SYMBOL
	Symbol string `json:"symbol"`

	// To DTO.WALLET.TX_HISTORY.TO
	To string `json:"to"`

	// ToTokenAccount DTO.WALLET.TX_HISTORY.TO_TOKEN_ACCOUNT
	ToTokenAccount string `json:"toTokenAccount"`

	// ToUserAccount DTO.WALLET.TX_HISTORY.TO_USER_ACCOUNT
	ToUserAccount string `json:"toUserAccount"`

	// TokenAddress DTO.WALLET.TX_HISTORY.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// TokenAmount DTO.WALLET.TX_HISTORY.TOKEN_AMOUNT
	TokenAmount string `json:"tokenAmount"`

	// TokenAmountInUsd DTO.WALLET.TX_HISTORY.TOKEN_AMOUNT_IN_USD
	TokenAmountInUsd string `json:"tokenAmountInUsd"`

	// TokenPriceInUsd DTO.WALLET.TX_HISTORY.TOKEN_PRICE_IN_USD
	TokenPriceInUsd string `json:"tokenPriceInUsd"`

	// TxHash DTO.WALLET.TX_HISTORY.TX_HASH
	TxHash string `json:"txHash"`
}

// TransactionHistoryItemDTOMainAction DTO.WALLET.TX_HISTORY.MAIN_ACTION
type TransactionHistoryItemDTOMainAction string

// TransactionHistoryItemDTOStatus DTO.WALLET.TX_HISTORY.STATUS
type TransactionHistoryItemDTOStatus string

// TransactionHistoryPage defines model for TransactionHistoryPage.
type TransactionHistoryPage struct {
	// Data DTO.PAGE.DATA
	Data []TransactionHistoryItemDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`
}

// WalletFirstTxDTO defines model for WalletFirstTxDTO.
type WalletFirstTxDTO struct {
	// Wallets DTO.WALLET.FIRST_TX.TX_HASH
	Wallets map[string]interface{} `json:"wallets"`
}

// WalletNetWorthChartDTO defines model for WalletNetWorthChartDTO.
type WalletNetWorthChartDTO struct {
	// CurrentTimestamp DTO.WALLET.NET_WORTH_CHART.CURRENT_TIMESTAMP
	CurrentTimestamp string `json:"currentTimestamp"`

	// History DTO.WALLET.NET_WORTH_CHART.HISTORY
	History []WalletNetWorthHistoryItemDTO `json:"history"`

	// PastTimestamp DTO.WALLET.NET_WORTH_CHART.PAST_TIMESTAMP
	PastTimestamp string `json:"pastTimestamp"`

	// WalletAddress DTO.WALLET.NET_WORTH_CHART.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// WalletNetWorthDetailsPage defines model for WalletNetWorthDetailsPage.
type WalletNetWorthDetailsPage struct {
	// Data DTO.PAGE.DATA
	Data []WalletNetWorthItemDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// NetWorth DTO.WALLET.NET_WORTH_DETAILS.NET_WORTH
	NetWorth string `json:"netWorth"`

	// RequestedTimestamp DTO.WALLET.NET_WORTH_DETAILS.REQUESTED_TIMESTAMP
	RequestedTimestamp string `json:"requestedTimestamp"`

	// ResolvedTimestamp DTO.WALLET.NET_WORTH_DETAILS.RESOLVED_TIMESTAMP
	ResolvedTimestamp string `json:"resolvedTimestamp"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`

	// WalletAddress DTO.WALLET.NET_WORTH_DETAILS.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// WalletNetWorthHistoryItemDTO defines model for WalletNetWorthHistoryItemDTO.
type WalletNetWorthHistoryItemDTO struct {
	// NetWorth DTO.WALLET.NET_WORTH_CHART.ITEM.NET_WORTH
	NetWorth string `json:"netWorth"`

	// NetWorthChange DTO.WALLET.NET_WORTH_CHART.ITEM.NET_WORTH_CHANGE
	NetWorthChange string `json:"netWorthChange"`

	// NetWorthChangePercent DTO.WALLET.NET_WORTH_CHART.ITEM.NET_WORTH_CHANGE_PERCENT
	NetWorthChangePercent string `json:"netWorthChangePercent"`

	// Timestamp DTO.WALLET.NET_WORTH_CHART.ITEM.TIMESTAMP
	Timestamp string `json:"timestamp"`
}

// WalletNetWorthItemDTO defines model for WalletNetWorthItemDTO.
type WalletNetWorthItemDTO struct {
	// Amount DTO.WALLET.NET_WORTH.ITEM.AMOUNT
	Amount string `json:"amount"`

	// Chain GLOBAL.CHAIN.DESCRIPTION
	Chain string `json:"chain"`

	// Decimals DTO.WALLET.NET_WORTH.ITEM.DECIMALS
	Decimals int64 `json:"decimals"`

	// LogoUri DTO.WALLET.NET_WORTH.ITEM.LOGO_URI
	LogoUri *string `json:"logoUri,omitempty"`

	// Name DTO.WALLET.NET_WORTH.ITEM.NAME
	Name string `json:"name"`

	// PriceInNative DTO.WALLET.NET_WORTH.ITEM.PRICE_IN_NATIVE
	PriceInNative string `json:"priceInNative"`

	// PriceInUsd DTO.WALLET.NET_WORTH.ITEM.PRICE_IN_USD
	PriceInUsd string `json:"priceInUsd"`

	// Symbol DTO.WALLET.NET_WORTH.ITEM.SYMBOL
	Symbol string `json:"symbol"`

	// TokenAddress DTO.WALLET.NET_WORTH.ITEM.TOKEN_ADDRESS
	TokenAddress string `json:"tokenAddress"`

	// ValueInNative DTO.WALLET.NET_WORTH.ITEM.VALUE_IN_NATIVE
	ValueInNative string `json:"valueInNative"`

	// ValueInUsd DTO.WALLET.NET_WORTH.ITEM.VALUE_IN_USD
	ValueInUsd string `json:"valueInUsd"`
}

// WalletNetWorthPage defines model for WalletNetWorthPage.
type WalletNetWorthPage struct {
	// CurrentTimestamp DTO.WALLET.NET_WORTH.CURRENT_TIMESTAMP
	CurrentTimestamp string `json:"currentTimestamp"`

	// Data DTO.PAGE.DATA
	Data []WalletNetWorthItemDTO `json:"data"`

	// EndCursor DTO.PAGE.END_CURSOR
	EndCursor *string `json:"endCursor,omitempty"`

	// HasNext DTO.PAGE.HAS_NEXT
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrev DTO.PAGE.HAS_PREV
	HasPrev *bool `json:"hasPrev,omitempty"`

	// StartCursor DTO.PAGE.START_CURSOR
	StartCursor *string `json:"startCursor,omitempty"`

	// Total DTO.PAGE.TOTAL
	Total *int64 `json:"total,omitempty"`

	// TotalValueInNative DTO.WALLET.NET_WORTH.TOTAL_VALUE_IN_NATIVE
	TotalValueInNative string `json:"totalValueInNative"`

	// TotalValueInUsd DTO.WALLET.NET_WORTH.TOTAL_VALUE_IN_USD
	TotalValueInUsd string `json:"totalValueInUsd"`

	// WalletAddress DTO.WALLET.NET_WORTH.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`
}

// WalletNetWorthSummaryDTO defines model for WalletNetWorthSummaryDTO.
type WalletNetWorthSummaryDTO struct {
	// CurrentTimestamp DTO.WALLET.NET_WORTH_SUMMARY.CURRENT_TIMESTAMP
	CurrentTimestamp string `json:"currentTimestamp"`

	// Wallets DTO.WALLET.NET_WORTH_SUMMARY.WALLETS
	Wallets map[string]interface{} `json:"wallets"`
}

// WalletPnlSummaryDTO defines model for WalletPnlSummaryDTO.
type WalletPnlSummaryDTO struct {
	// AvgProfitPerTradeInUsd DTO.WALLET.PNL_SUMMARY.AVG_PROFIT_PER_TRADE_IN_USD
	AvgProfitPerTradeInUsd string `json:"avgProfitPerTradeInUsd"`

	// BuyAmountInUsd DTO.WALLET.PNL_SUMMARY.BUY_AMOUNT_IN_USD
	BuyAmountInUsd string `json:"buyAmountInUsd"`

	// Buys DTO.WALLET.PNL_SUMMARY.BUYS
	Buys string `json:"buys"`

	// Losses DTO.WALLET.PNL_SUMMARY.LOSSES
	Losses string `json:"losses"`

	// RealizedProfitInUsd DTO.WALLET.PNL_SUMMARY.REALIZED_PROFIT_IN_USD
	RealizedProfitInUsd string `json:"realizedProfitInUsd"`

	// RealizedProfitRatio DTO.WALLET.PNL_SUMMARY.REALIZED_PROFIT_RATIO
	RealizedProfitRatio string `json:"realizedProfitRatio"`

	// Resolution DTO.WALLET.PNL_SUMMARY.RESOLUTION
	Resolution WalletPnlSummaryDTOResolution `json:"resolution"`

	// SellAmountInUsd DTO.WALLET.PNL_SUMMARY.SELL_AMOUNT_IN_USD
	SellAmountInUsd string `json:"sellAmountInUsd"`

	// Sells DTO.WALLET.PNL_SUMMARY.SELLS
	Sells string `json:"sells"`

	// Tokens DTO.WALLET.PNL_SUMMARY.TOKENS
	Tokens string `json:"tokens"`

	// TotalCostInUsd DTO.WALLET.PNL_SUMMARY.TOTAL_COST_IN_USD
	TotalCostInUsd string `json:"totalCostInUsd"`

	// TotalProfitInUsd DTO.WALLET.PNL_SUMMARY.TOTAL_PROFIT_IN_USD
	TotalProfitInUsd string `json:"totalProfitInUsd"`

	// TotalProfitRatio DTO.WALLET.PNL_SUMMARY.TOTAL_PROFIT_RATIO
	TotalProfitRatio string `json:"totalProfitRatio"`

	// TotalTrades DTO.WALLET.PNL_SUMMARY.TOTAL_TRADES
	TotalTrades string `json:"totalTrades"`

	// UnrealizedProfitInUsd DTO.WALLET.PNL_SUMMARY.UNREALIZED_PROFIT_IN_USD
	UnrealizedProfitInUsd string `json:"unrealizedProfitInUsd"`

	// UnrealizedProfitRatio DTO.WALLET.PNL_SUMMARY.UNREALIZED_PROFIT_RATIO
	UnrealizedProfitRatio string `json:"unrealizedProfitRatio"`

	// UpdatedAt DTO.WALLET.PNL_SUMMARY.UPDATED_AT
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// WalletAddress DTO.WALLET.PNL_SUMMARY.WALLET_ADDRESS
	WalletAddress string `json:"walletAddress"`

	// WinRate DTO.WALLET.PNL_SUMMARY.WIN_RATE
	WinRate string `json:"winRate"`

	// Wins DTO.WALLET.PNL_SUMMARY.WINS
	Wins string `json:"wins"`
}

// WalletPnlSummaryDTOResolution DTO.WALLET.PNL_SUMMARY.RESOLUTION
type WalletPnlSummaryDTOResolution string

// GetWalletFirstTxParams defines parameters for GetWalletFirstTx.
type GetWalletFirstTxParams struct {
	// WalletAddresses GLOBAL.WALLETADDRESSES.DESCRIPTION
	WalletAddresses string `form:"walletAddresses" json:"walletAddresses"`
}

// GetNetWorthSummaryParams defines parameters for GetNetWorthSummary.
type GetNetWorthSummaryParams struct {
	// WalletAddresses GLOBAL.WALLETADDRESSES.DESCRIPTION
	WalletAddresses string `form:"walletAddresses" json:"walletAddresses"`
}

// GetPnlByWalletParams defines parameters for GetPnlByWallet.
type GetPnlByWalletParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetPnlByWalletParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// WalletAddresses GLOBAL.WALLETADDRESSES.DESCRIPTION
	WalletAddresses string `form:"walletAddresses" json:"walletAddresses"`

	// TokenAddress GLOBAL.TOKENADDRESS.DESCRIPTION
	TokenAddress string `form:"tokenAddress" json:"tokenAddress"`
}

// GetPnlByWalletParamsDirection defines parameters for GetPnlByWallet.
type GetPnlByWalletParamsDirection string

// GetBalanceUpdatesParams defines parameters for GetBalanceUpdates.
type GetBalanceUpdatesParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetBalanceUpdatesParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// TokenAddress DTO.WALLET.BALANCE_UPDATE.QUERY.TOKEN_ADDRESS
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`

	// TimeFrom DTO.WALLET.BALANCE_UPDATE.QUERY.TIME_FROM
	TimeFrom *int64 `form:"timeFrom,omitempty" json:"timeFrom,omitempty"`

	// TimeTo DTO.WALLET.BALANCE_UPDATE.QUERY.TIME_TO
	TimeTo *int64 `form:"timeTo,omitempty" json:"timeTo,omitempty"`

	// Type DTO.WALLET.BALANCE_UPDATE.QUERY.TYPE
	Type *BalanceTokenType `form:"type,omitempty" json:"type,omitempty"`

	// ChangeType DTO.WALLET.BALANCE_UPDATE.QUERY.CHANGE_TYPE
	ChangeType *BalanceChangeType `form:"changeType,omitempty" json:"changeType,omitempty"`
}

// GetBalanceUpdatesParamsDirection defines parameters for GetBalanceUpdates.
type GetBalanceUpdatesParamsDirection string

// GetNetWorthParams defines parameters for GetNetWorth.
type GetNetWorthParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetNetWorthParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetNetWorthParamsDirection defines parameters for GetNetWorth.
type GetNetWorthParamsDirection string

// GetNetWorthChartParams defines parameters for GetNetWorthChart.
type GetNetWorthChartParams struct {
	// Hours DTO.WALLET.NET_WORTH_CHART.QUERY.HOURS
	Hours *int32 `form:"hours,omitempty" json:"hours,omitempty"`
}

// GetNetWorthDetailsParams defines parameters for GetNetWorthDetails.
type GetNetWorthDetailsParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetNetWorthDetailsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// Hours DTO.WALLET.NET_WORTH_DETAILS.QUERY.HOURS
	Hours *int32 `form:"hours,omitempty" json:"hours,omitempty"`
}

// GetNetWorthDetailsParamsDirection defines parameters for GetNetWorthDetails.
type GetNetWorthDetailsParamsDirection string

// GetPnlParams defines parameters for GetPnl.
type GetPnlParams struct {
	// Resolution DTO.WALLET.PNL_SUMMARY.QUERY.RESOLUTION
	Resolution *PnlResolution `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// GetPnlByTokenParams defines parameters for GetPnlByToken.
type GetPnlByTokenParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetPnlByTokenParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// TokenAddresses GLOBAL.TOKENADDRESSES.DESCRIPTION
	TokenAddresses string `form:"tokenAddresses" json:"tokenAddresses"`
}

// GetPnlByTokenParamsDirection defines parameters for GetPnlByToken.
type GetPnlByTokenParamsDirection string

// GetPnlDetailsParams defines parameters for GetPnlDetails.
type GetPnlDetailsParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetPnlDetailsParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetPnlDetailsParamsDirection defines parameters for GetPnlDetails.
type GetPnlDetailsParamsDirection string

// GetTokensBalanceParams defines parameters for GetTokensBalance.
type GetTokensBalanceParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetTokensBalanceParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// GetTokensBalanceParamsDirection defines parameters for GetTokensBalance.
type GetTokensBalanceParamsDirection string

// GetWalletTransferTotalParams defines parameters for GetWalletTransferTotal.
type GetWalletTransferTotalParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetWalletTransferTotalParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// TokenAddress GLOBAL.TOKENADDRESS.DESCRIPTION
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`

	// BeforeTimestamp DTO.TOKEN.TRANSFER.QUERY.BEFORE_TIMESTAMP
	BeforeTimestamp *int64 `form:"beforeTimestamp,omitempty" json:"beforeTimestamp,omitempty"`

	// AfterTimestamp DTO.TOKEN.TRANSFER.QUERY.AFTER_TIMESTAMP
	AfterTimestamp *int64 `form:"afterTimestamp,omitempty" json:"afterTimestamp,omitempty"`
}

// GetWalletTransferTotalParamsDirection defines parameters for GetWalletTransferTotal.
type GetWalletTransferTotalParamsDirection string

// GetWalletTransfersParams defines parameters for GetWalletTransfers.
type GetWalletTransfersParams struct {
	// Cursor DTO.PAGE.CURSOR.DESCRIPTION
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit DTO.PAGE.LIMIT
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Direction DTO.PAGE.DIRECTION
	Direction *GetWalletTransfersParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`

	// TokenAddress GLOBAL.TOKENADDRESS.DESCRIPTION
	TokenAddress *string `form:"tokenAddress,omitempty" json:"tokenAddress,omitempty"`

	// BeforeTimestamp DTO.TOKEN.TRANSFER.QUERY.BEFORE_TIMESTAMP
	BeforeTimestamp *int64 `form:"beforeTimestamp,omitempty" json:"beforeTimestamp,omitempty"`

	// AfterTimestamp DTO.TOKEN.TRANSFER.QUERY.AFTER_TIMESTAMP
	AfterTimestamp *int64 `form:"afterTimestamp,omitempty" json:"afterTimestamp,omitempty"`
}

// GetWalletTransfersParamsDirection defines parameters for GetWalletTransfers.
type GetWalletTransfersParamsDirection string

// CalculatePnlJSONRequestBody defines body for CalculatePnl for application/json ContentType.
type CalculatePnlJSONRequestBody = CalculatePnlInput

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetWalletFirstTx request
	GetWalletFirstTx(ctx context.Context, chain ChainSymbol, params *GetWalletFirstTxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetWorthSummary request
	GetNetWorthSummary(ctx context.Context, chain ChainSymbol, params *GetNetWorthSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPnlByWallet request
	GetPnlByWallet(ctx context.Context, chain ChainSymbol, params *GetPnlByWalletParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalanceUpdates request
	GetBalanceUpdates(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculatePnlWithBody request with any body
	CalculatePnlWithBody(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculatePnl(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetWorth request
	GetNetWorth(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetWorthChart request
	GetNetWorthChart(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetWorthDetails request
	GetNetWorthDetails(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPnl request
	GetPnl(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPnlByToken request
	GetPnlByToken(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlByTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPnlDetails request
	GetPnlDetails(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokensBalance request
	GetTokensBalance(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetTokensBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletTransferTotal request
	GetWalletTransferTotal(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransferTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletTransfers request
	GetWalletTransfers(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetWalletFirstTx(ctx context.Context, chain ChainSymbol, params *GetWalletFirstTxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletFirstTxRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetWorthSummary(ctx context.Context, chain ChainSymbol, params *GetNetWorthSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetWorthSummaryRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPnlByWallet(ctx context.Context, chain ChainSymbol, params *GetPnlByWalletParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlByWalletRequest(c.Server, chain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalanceUpdates(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceUpdatesRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculatePnlWithBody(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculatePnlRequestWithBody(c.Server, chain, walletAddress, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculatePnl(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculatePnlRequest(c.Server, chain, walletAddress, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetWorth(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetWorthRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetWorthChart(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetWorthChartRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetWorthDetails(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetWorthDetailsRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPnl(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPnlByToken(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlByTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlByTokenRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPnlDetails(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPnlDetailsRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokensBalance(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetTokensBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokensBalanceRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletTransferTotal(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransferTotalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletTransferTotalRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletTransfers(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransfersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletTransfersRequest(c.Server, chain, walletAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetWalletFirstTxRequest generates requests for GetWalletFirstTx
func NewGetWalletFirstTxRequest(server string, chain ChainSymbol, params *GetWalletFirstTxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/first-tx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walletAddresses", runtime.ParamLocationQuery, params.WalletAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetWorthSummaryRequest generates requests for GetNetWorthSummary
func NewGetNetWorthSummaryRequest(server string, chain ChainSymbol, params *GetNetWorthSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/net-worth-summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walletAddresses", runtime.ParamLocationQuery, params.WalletAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPnlByWalletRequest generates requests for GetPnlByWallet
func NewGetPnlByWalletRequest(server string, chain ChainSymbol, params *GetPnlByWalletParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/pnl-by-wallet", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walletAddresses", runtime.ParamLocationQuery, params.WalletAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, params.TokenAddress); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBalanceUpdatesRequest generates requests for GetBalanceUpdates
func NewGetBalanceUpdatesRequest(server string, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/balance-updates", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeFrom", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeTo", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChangeType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changeType", runtime.ParamLocationQuery, *params.ChangeType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCalculatePnlRequest calls the generic CalculatePnl builder with application/json body
func NewCalculatePnlRequest(server string, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculatePnlRequestWithBody(server, chain, walletAddress, "application/json", bodyReader)
}

// NewCalculatePnlRequestWithBody generates requests for CalculatePnl with any type of body
func NewCalculatePnlRequestWithBody(server string, chain ChainSymbol, walletAddress string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/calculate-pnl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNetWorthRequest generates requests for GetNetWorth
func NewGetNetWorthRequest(server string, chain ChainSymbol, walletAddress string, params *GetNetWorthParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/net-worth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetWorthChartRequest generates requests for GetNetWorthChart
func NewGetNetWorthChartRequest(server string, chain ChainSymbol, walletAddress string, params *GetNetWorthChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/net-worth-chart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hours != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hours", runtime.ParamLocationQuery, *params.Hours); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetWorthDetailsRequest generates requests for GetNetWorthDetails
func NewGetNetWorthDetailsRequest(server string, chain ChainSymbol, walletAddress string, params *GetNetWorthDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/net-worth-details", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hours != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hours", runtime.ParamLocationQuery, *params.Hours); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPnlRequest generates requests for GetPnl
func NewGetPnlRequest(server string, chain ChainSymbol, walletAddress string, params *GetPnlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/pnl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPnlByTokenRequest generates requests for GetPnlByToken
func NewGetPnlByTokenRequest(server string, chain ChainSymbol, walletAddress string, params *GetPnlByTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/pnl-by-token", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddresses", runtime.ParamLocationQuery, params.TokenAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPnlDetailsRequest generates requests for GetPnlDetails
func NewGetPnlDetailsRequest(server string, chain ChainSymbol, walletAddress string, params *GetPnlDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/pnl-details", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokensBalanceRequest generates requests for GetTokensBalance
func NewGetTokensBalanceRequest(server string, chain ChainSymbol, walletAddress string, params *GetTokensBalanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/tokens-balance", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWalletTransferTotalRequest generates requests for GetWalletTransferTotal
func NewGetWalletTransferTotalRequest(server string, chain ChainSymbol, walletAddress string, params *GetWalletTransferTotalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/transfer-total", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "beforeTimestamp", runtime.ParamLocationQuery, *params.BeforeTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "afterTimestamp", runtime.ParamLocationQuery, *params.AfterTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWalletTransfersRequest generates requests for GetWalletTransfers
func NewGetWalletTransfersRequest(server string, chain ChainSymbol, walletAddress string, params *GetWalletTransfersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chain", runtime.ParamLocationPath, chain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "walletAddress", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wallet/%s/%s/transfers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TokenAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenAddress", runtime.ParamLocationQuery, *params.TokenAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "beforeTimestamp", runtime.ParamLocationQuery, *params.BeforeTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterTimestamp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "afterTimestamp", runtime.ParamLocationQuery, *params.AfterTimestamp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetWalletFirstTxWithResponse request
	GetWalletFirstTxWithResponse(ctx context.Context, chain ChainSymbol, params *GetWalletFirstTxParams, reqEditors ...RequestEditorFn) (*GetWalletFirstTxResponse, error)

	// GetNetWorthSummaryWithResponse request
	GetNetWorthSummaryWithResponse(ctx context.Context, chain ChainSymbol, params *GetNetWorthSummaryParams, reqEditors ...RequestEditorFn) (*GetNetWorthSummaryResponse, error)

	// GetPnlByWalletWithResponse request
	GetPnlByWalletWithResponse(ctx context.Context, chain ChainSymbol, params *GetPnlByWalletParams, reqEditors ...RequestEditorFn) (*GetPnlByWalletResponse, error)

	// GetBalanceUpdatesWithResponse request
	GetBalanceUpdatesWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBalanceUpdatesResponse, error)

	// CalculatePnlWithBodyWithResponse request with any body
	CalculatePnlWithBodyWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error)

	CalculatePnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error)

	// GetNetWorthWithResponse request
	GetNetWorthWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthParams, reqEditors ...RequestEditorFn) (*GetNetWorthResponse, error)

	// GetNetWorthChartWithResponse request
	GetNetWorthChartWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthChartParams, reqEditors ...RequestEditorFn) (*GetNetWorthChartResponse, error)

	// GetNetWorthDetailsWithResponse request
	GetNetWorthDetailsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthDetailsParams, reqEditors ...RequestEditorFn) (*GetNetWorthDetailsResponse, error)

	// GetPnlWithResponse request
	GetPnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*GetPnlResponse, error)

	// GetPnlByTokenWithResponse request
	GetPnlByTokenWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlByTokenParams, reqEditors ...RequestEditorFn) (*GetPnlByTokenResponse, error)

	// GetPnlDetailsWithResponse request
	GetPnlDetailsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlDetailsParams, reqEditors ...RequestEditorFn) (*GetPnlDetailsResponse, error)

	// GetTokensBalanceWithResponse request
	GetTokensBalanceWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetTokensBalanceParams, reqEditors ...RequestEditorFn) (*GetTokensBalanceResponse, error)

	// GetWalletTransferTotalWithResponse request
	GetWalletTransferTotalWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransferTotalParams, reqEditors ...RequestEditorFn) (*GetWalletTransferTotalResponse, error)

	// GetWalletTransfersWithResponse request
	GetWalletTransfersWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransfersParams, reqEditors ...RequestEditorFn) (*GetWalletTransfersResponse, error)
}

type GetWalletFirstTxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletFirstTxDTO
}

// Status returns HTTPResponse.Status
func (r GetWalletFirstTxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletFirstTxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetWorthSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletNetWorthSummaryDTO
}

// Status returns HTTPResponse.Status
func (r GetNetWorthSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetWorthSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPnlByWalletResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PnlDetailsPage
}

// Status returns HTTPResponse.Status
func (r GetPnlByWalletResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlByWalletResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BalanceUpdatePage
}

// Status returns HTTPResponse.Status
func (r GetBalanceUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculatePnlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BooleanResultDTO
}

// Status returns HTTPResponse.Status
func (r CalculatePnlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculatePnlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetWorthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletNetWorthPage
}

// Status returns HTTPResponse.Status
func (r GetNetWorthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetWorthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetWorthChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletNetWorthChartDTO
}

// Status returns HTTPResponse.Status
func (r GetNetWorthChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetWorthChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetWorthDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletNetWorthDetailsPage
}

// Status returns HTTPResponse.Status
func (r GetNetWorthDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetWorthDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPnlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WalletPnlSummaryDTO
}

// Status returns HTTPResponse.Status
func (r GetPnlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPnlByTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PnlDetailsPage
}

// Status returns HTTPResponse.Status
func (r GetPnlByTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlByTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPnlDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PnlDetailsPage
}

// Status returns HTTPResponse.Status
func (r GetPnlDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPnlDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokensBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokensBalancePage
}

// Status returns HTTPResponse.Status
func (r GetTokensBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokensBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletTransferTotalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenTransferTotalDTO
}

// Status returns HTTPResponse.Status
func (r GetWalletTransferTotalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletTransferTotalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletTransfersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionHistoryPage
}

// Status returns HTTPResponse.Status
func (r GetWalletTransfersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletTransfersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetWalletFirstTxWithResponse request returning *GetWalletFirstTxResponse
func (c *ClientWithResponses) GetWalletFirstTxWithResponse(ctx context.Context, chain ChainSymbol, params *GetWalletFirstTxParams, reqEditors ...RequestEditorFn) (*GetWalletFirstTxResponse, error) {
	rsp, err := c.GetWalletFirstTx(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletFirstTxResponse(rsp)
}

// GetNetWorthSummaryWithResponse request returning *GetNetWorthSummaryResponse
func (c *ClientWithResponses) GetNetWorthSummaryWithResponse(ctx context.Context, chain ChainSymbol, params *GetNetWorthSummaryParams, reqEditors ...RequestEditorFn) (*GetNetWorthSummaryResponse, error) {
	rsp, err := c.GetNetWorthSummary(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetWorthSummaryResponse(rsp)
}

// GetPnlByWalletWithResponse request returning *GetPnlByWalletResponse
func (c *ClientWithResponses) GetPnlByWalletWithResponse(ctx context.Context, chain ChainSymbol, params *GetPnlByWalletParams, reqEditors ...RequestEditorFn) (*GetPnlByWalletResponse, error) {
	rsp, err := c.GetPnlByWallet(ctx, chain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlByWalletResponse(rsp)
}

// GetBalanceUpdatesWithResponse request returning *GetBalanceUpdatesResponse
func (c *ClientWithResponses) GetBalanceUpdatesWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetBalanceUpdatesParams, reqEditors ...RequestEditorFn) (*GetBalanceUpdatesResponse, error) {
	rsp, err := c.GetBalanceUpdates(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceUpdatesResponse(rsp)
}

// CalculatePnlWithBodyWithResponse request with arbitrary body returning *CalculatePnlResponse
func (c *ClientWithResponses) CalculatePnlWithBodyWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error) {
	rsp, err := c.CalculatePnlWithBody(ctx, chain, walletAddress, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculatePnlResponse(rsp)
}

func (c *ClientWithResponses) CalculatePnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, body CalculatePnlJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculatePnlResponse, error) {
	rsp, err := c.CalculatePnl(ctx, chain, walletAddress, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculatePnlResponse(rsp)
}

// GetNetWorthWithResponse request returning *GetNetWorthResponse
func (c *ClientWithResponses) GetNetWorthWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthParams, reqEditors ...RequestEditorFn) (*GetNetWorthResponse, error) {
	rsp, err := c.GetNetWorth(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetWorthResponse(rsp)
}

// GetNetWorthChartWithResponse request returning *GetNetWorthChartResponse
func (c *ClientWithResponses) GetNetWorthChartWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthChartParams, reqEditors ...RequestEditorFn) (*GetNetWorthChartResponse, error) {
	rsp, err := c.GetNetWorthChart(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetWorthChartResponse(rsp)
}

// GetNetWorthDetailsWithResponse request returning *GetNetWorthDetailsResponse
func (c *ClientWithResponses) GetNetWorthDetailsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetNetWorthDetailsParams, reqEditors ...RequestEditorFn) (*GetNetWorthDetailsResponse, error) {
	rsp, err := c.GetNetWorthDetails(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetWorthDetailsResponse(rsp)
}

// GetPnlWithResponse request returning *GetPnlResponse
func (c *ClientWithResponses) GetPnlWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlParams, reqEditors ...RequestEditorFn) (*GetPnlResponse, error) {
	rsp, err := c.GetPnl(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlResponse(rsp)
}

// GetPnlByTokenWithResponse request returning *GetPnlByTokenResponse
func (c *ClientWithResponses) GetPnlByTokenWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlByTokenParams, reqEditors ...RequestEditorFn) (*GetPnlByTokenResponse, error) {
	rsp, err := c.GetPnlByToken(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlByTokenResponse(rsp)
}

// GetPnlDetailsWithResponse request returning *GetPnlDetailsResponse
func (c *ClientWithResponses) GetPnlDetailsWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetPnlDetailsParams, reqEditors ...RequestEditorFn) (*GetPnlDetailsResponse, error) {
	rsp, err := c.GetPnlDetails(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPnlDetailsResponse(rsp)
}

// GetTokensBalanceWithResponse request returning *GetTokensBalanceResponse
func (c *ClientWithResponses) GetTokensBalanceWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetTokensBalanceParams, reqEditors ...RequestEditorFn) (*GetTokensBalanceResponse, error) {
	rsp, err := c.GetTokensBalance(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokensBalanceResponse(rsp)
}

// GetWalletTransferTotalWithResponse request returning *GetWalletTransferTotalResponse
func (c *ClientWithResponses) GetWalletTransferTotalWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransferTotalParams, reqEditors ...RequestEditorFn) (*GetWalletTransferTotalResponse, error) {
	rsp, err := c.GetWalletTransferTotal(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletTransferTotalResponse(rsp)
}

// GetWalletTransfersWithResponse request returning *GetWalletTransfersResponse
func (c *ClientWithResponses) GetWalletTransfersWithResponse(ctx context.Context, chain ChainSymbol, walletAddress string, params *GetWalletTransfersParams, reqEditors ...RequestEditorFn) (*GetWalletTransfersResponse, error) {
	rsp, err := c.GetWalletTransfers(ctx, chain, walletAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletTransfersResponse(rsp)
}

// ParseGetWalletFirstTxResponse parses an HTTP response from a GetWalletFirstTxWithResponse call
func ParseGetWalletFirstTxResponse(rsp *http.Response) (*GetWalletFirstTxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletFirstTxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletFirstTxDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetWorthSummaryResponse parses an HTTP response from a GetNetWorthSummaryWithResponse call
func ParseGetNetWorthSummaryResponse(rsp *http.Response) (*GetNetWorthSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetWorthSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletNetWorthSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPnlByWalletResponse parses an HTTP response from a GetPnlByWalletWithResponse call
func ParseGetPnlByWalletResponse(rsp *http.Response) (*GetPnlByWalletResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlByWalletResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PnlDetailsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBalanceUpdatesResponse parses an HTTP response from a GetBalanceUpdatesWithResponse call
func ParseGetBalanceUpdatesResponse(rsp *http.Response) (*GetBalanceUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BalanceUpdatePage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCalculatePnlResponse parses an HTTP response from a CalculatePnlWithResponse call
func ParseCalculatePnlResponse(rsp *http.Response) (*CalculatePnlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculatePnlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BooleanResultDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetWorthResponse parses an HTTP response from a GetNetWorthWithResponse call
func ParseGetNetWorthResponse(rsp *http.Response) (*GetNetWorthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetWorthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletNetWorthPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetWorthChartResponse parses an HTTP response from a GetNetWorthChartWithResponse call
func ParseGetNetWorthChartResponse(rsp *http.Response) (*GetNetWorthChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetWorthChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletNetWorthChartDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetWorthDetailsResponse parses an HTTP response from a GetNetWorthDetailsWithResponse call
func ParseGetNetWorthDetailsResponse(rsp *http.Response) (*GetNetWorthDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetWorthDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletNetWorthDetailsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPnlResponse parses an HTTP response from a GetPnlWithResponse call
func ParseGetPnlResponse(rsp *http.Response) (*GetPnlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WalletPnlSummaryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPnlByTokenResponse parses an HTTP response from a GetPnlByTokenWithResponse call
func ParseGetPnlByTokenResponse(rsp *http.Response) (*GetPnlByTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlByTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PnlDetailsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPnlDetailsResponse parses an HTTP response from a GetPnlDetailsWithResponse call
func ParseGetPnlDetailsResponse(rsp *http.Response) (*GetPnlDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPnlDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PnlDetailsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTokensBalanceResponse parses an HTTP response from a GetTokensBalanceWithResponse call
func ParseGetTokensBalanceResponse(rsp *http.Response) (*GetTokensBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTokensBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokensBalancePage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWalletTransferTotalResponse parses an HTTP response from a GetWalletTransferTotalWithResponse call
func ParseGetWalletTransferTotalResponse(rsp *http.Response) (*GetWalletTransferTotalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletTransferTotalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenTransferTotalDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWalletTransfersResponse parses an HTTP response from a GetWalletTransfersWithResponse call
func ParseGetWalletTransfersResponse(rsp *http.Response) (*GetWalletTransfersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletTransfersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionHistoryPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
